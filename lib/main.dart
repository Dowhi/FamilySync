import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:calendario_familiar/core/firebase/firebase_options.dart';
import 'package:calendario_familiar/routing/app_router.dart';
import 'package:calendario_familiar/theme/app_theme.dart';
import 'package:calendario_familiar/core/services/time_service.dart';
import 'package:calendario_familiar/core/services/notification_service.dart';
import 'package:calendario_familiar/core/services/alarm_service.dart';
import 'package:calendario_familiar/core/providers/theme_provider.dart';
import 'package:calendario_familiar/core/providers/current_user_provider.dart';
import 'package:go_router/go_router.dart';

void main(List<String> args) async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Forzar nuevo despliegue - versi√≥n sin login
  
  // Forzar recompilaci√≥n para eliminar pantalla de login
  
  // Inicializar Firebase INMEDIATAMENTE para web
  try {
    if (Firebase.apps.isEmpty) {
      await Firebase.initializeApp(
        options: DefaultFirebaseOptions.currentPlatform,
      );
      print('‚úÖ Firebase inicializado correctamente');
    } else {
      print('‚ÑπÔ∏è Firebase ya estaba inicializado');
    }
  } catch (e) {
    print('‚ùå Error inicializando Firebase: $e');
  }
  
  // Procesar argumentos si venimos desde AlarmActivity
  if (args.isNotEmpty) {
    for (final arg in args) {
      print('üîî Argumento recibido: $arg');
      if (arg.startsWith('--route=')) {
        final route = arg.substring(8); // Quitar "--route="
        print('üîî Ruta recibida: $route');
        
        // Parsear query parameters
        final uri = Uri.parse(route);
        if (uri.path == '/alarm' && uri.queryParameters.isNotEmpty) {
          initialAlarmData = uri.queryParameters;
          openedFromNotification = true;
          print('üîî initialAlarmData establecido desde args: $initialAlarmData');
        }
      }
    }
  }

  // Inicializar AlarmService temprano (requerido por android_alarm_manager_plus)
  try {
    await AlarmService.initialize();
    print('‚úÖ AlarmService inicializado temprano');
  } catch (e) {
    print('‚ùå Error inicializando AlarmService temprano: $e');
  }

  // Arrancar la UI
  final container = ProviderContainer();
  
  // üîπ Establecer el listener para actualizar el userId en NotificationService cuando cambie
  container.listen<int>(
    currentUserIdProvider,
    (previous, next) {
      NotificationService.setCurrentUserId(next);
      print('üîî UserId actualizado en NotificationService: $next');
    },
    fireImmediately: true,
  );
  
  runApp(UncontrolledProviderScope(container: container, child: const CalendarioFamiliarApp()));

  // Inicializaci√≥n diferida para servicios no cr√≠ticos
  Future(() async {

    try {
      if (!kIsWeb) {
        await TimeService.initialize();
        print('‚úÖ TimeService inicializado');

        await NotificationService.initialize(
          onSelectNotification: (payload) async {
            if (payload == null) return;
            print('üîî Payload recibido en main: $payload');
            if (payload.startsWith('alarm|')) {
              // NO navegar autom√°ticamente a la pantalla de alarma
              // ya que ahora usamos AlarmActivity nativa independiente
              print('üîî Notificaci√≥n de alarma tocada - AlarmActivity nativa ya se mostr√≥');
              print('üîî NO navegando a /alarm para evitar conflictos');
            }
          },
        );
        print('‚úÖ NotificationService inicializado');

        await AlarmService.initialize();
        print('‚úÖ AlarmService inicializado');

        // Solicitar permisos de notificaci√≥n
        final hasPermissions = await NotificationService.areNotificationsEnabled();
        if (!hasPermissions) {
          final granted = await NotificationService.requestPermissions();
          print(granted ? '‚úÖ Permisos concedidos' : '‚ùå Permisos denegados');
        }

        // Manejar arranque desde notificaci√≥n cuando la app estaba terminada
        final launch = await NotificationService.getNotificationAppLaunchDetails();
        final launched = launch?.didNotificationLaunchApp ?? false;
        if (launched) {
          final payload = launch!.notificationResponse?.payload;
          if (payload != null && payload.startsWith('alarm|')) {
            final parts = payload.split('|');
            final data = <String, String>{};
            for (final p in parts.skip(1)) {
              final i = p.indexOf('=');
              if (i > 0) {
                data[p.substring(0, i)] = Uri.decodeComponent(p.substring(i + 1));
              }
            }
            initialAlarmData = data;
            openedFromNotification = true;
            if (navigatorKey.currentState != null && navigatorKey.currentState!.context.mounted) {
              navigatorKey.currentState!.context.go(Uri(path: '/alarm', queryParameters: data).toString());
            }
          }
        }
        // iOS maneja las notificaciones de manera diferente
        // Las notificaciones se manejan a trav√©s del sistema nativo de iOS
      } else {
        print('‚ÑπÔ∏è Servicios de notificaciones locales no disponibles en web');
      }
    } catch (e) {
      print('‚ùå Error inicializando servicios base: $e');
    }
  });
}


class CalendarioFamiliarApp extends ConsumerWidget {
  const CalendarioFamiliarApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isDarkMode = ref.watch(themeProvider);
    
    return MaterialApp.router(
      title: 'Calendario Familiar',
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: isDarkMode ? ThemeMode.dark : ThemeMode.light,
      routerConfig: appRouter,
      debugShowCheckedModeBanner: false,
    );
  }
}