<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="FamilySync">
    <title>Calendario - FamilySync</title>
    <link rel="apple-touch-icon" href="icons/Icon-192.png">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        body {
            background: #f5f5f5;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: #1B5E20;
            color: white;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
            min-height: 44px;
        }

        .header-title {
            font-size: 16px;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .header-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 6px;
            padding: 6px 10px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .header-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        .menu-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 6px;
            padding: 6px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .menu-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Tab Navigation */
        .tab-nav {
            background: #1976D2;
            display: flex;
            flex-shrink: 0;
            min-height: 36px;
        }

        .tab-btn {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            padding: 8px 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            text-transform: uppercase;
        }

        .tab-btn.active {
            background: rgba(255, 255, 255, 0.2);
        }

        .tab-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Month Navigation */
        .month-nav {
            background: #2196F3;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
            min-height: 32px;
        }

        .month-nav button {
            background: transparent;
            border: none;
            padding: 0;
            width: 28px;
            height: 28px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .month-nav button:active {
            opacity: 0.7;
        }

        .month-title {
            font-size: 14px;
            font-weight: 600;
            color: white;
        }

        /* Settings Modal */
        .settings-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.4); display: none; align-items: flex-end; justify-content: center; z-index: 3000; }
        .settings-backdrop.show { display: flex; }
        .settings-panel { background: #ffffff; width: 100%; max-width: 520px; border-top-left-radius: 16px; border-top-right-radius: 16px; box-shadow: 0 -8px 24px rgba(0,0,0,0.2); padding: 16px; }
        .settings-header { display:flex; align-items:center; justify-content: space-between; margin-bottom: 8px; }
        .settings-title { font-size:16px; font-weight:700; }
        .settings-group { margin: 12px 0; padding: 12px; background:#f7f7f7; border-radius: 12px; }
        .settings-row { display:flex; align-items:center; justify-content: space-between; gap: 12px; padding: 8px 0; }
        .settings-row + .settings-row { border-top: 1px solid #eaeaea; }
        .settings-label { font-size:14px; font-weight:600; color:#333; }
        .settings-select, .settings-checkbox { margin-left: auto; }
        .settings-actions { display:flex; gap:8px; margin-top: 8px; }
        .btn { border:none; padding:10px 12px; border-radius:10px; font-weight:700; cursor:pointer; }
        .btn-primary { background:#2a7ade; color:#fff; }
        .btn-secondary { background:#e9e9e9; color:#333; }

        /* Calendar */
        .calendar-container {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 0;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0;
            margin-bottom: 0;
            height: 100%;
        }

        /* Celdas más altas cuando el mes sólo ocupa 5 semanas */
        .calendar-grid.five-weeks .calendar-day {
            min-height: calc((100vh - 160px) / 5);
        }

        .weekday-header {
            text-align: center;
            padding: 2px;
            font-size: 10px;
            font-weight: 600;
            color: #666;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f5f5f5;
            border: 1px solid #ddd;
        }

        .calendar-day {
            background: white;
            border: 1px solid #ddd;
            border-radius: 0;
            padding: 1px;
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: all 0.2s;
            overflow: hidden;
            min-height: calc((100vh - 160px) / 6);
            position: relative;
        }

        .calendar-day:active {
            transform: scale(0.95);
            background: #f9f9f9;
        }

        .calendar-day.other-month {
            opacity: 0.3;
            background: #f9f9f9;
        }

        .calendar-day.today {
            border: 2px solid #1B5E20;
            background: #f1f8e9;
        }

        /* Estilo específico para el número del día de hoy */
        .calendar-day.today .day-number {
            background: #FF1744; /* rojo fluorescente */
            color: #ffffff !important;
            border-radius: 50%;
            padding: 2px 6px;
        }

        .day-number {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 11px;
            font-weight: 600;
            line-height: 1;
            color: #333;
        }

        /* Iconos de categorías en las celdas */
        .category-icons {
            position: absolute;
            bottom: 2px;
            left: 2px;
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
            max-width: calc(100% - 20px);
        }

        .category-icon {
            font-size: 11px;
            line-height: 1;
            opacity: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 3px;
            padding: 2px 4px;
            border: 2px solid;
            font-weight: 600;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        /* Year view */
        .year-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #2e7d32;
            color: white;
        }
        .year-nav .title { font-weight: 700; }
        .year-nav button {
            width: 40px;
            height: 28px;
            color: white;
            background: rgba(255,255,255,0.15);
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        .year-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            padding: 8px;
        }
        .year-month {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        .year-month-header {
            background: #4da3ff;
            color: #fff;
            text-align: center;
            font-weight: 700;
            font-size: 12px;
            padding: 6px 0;
        }
        .year-month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
        }
        .year-weekday {
            text-align: center;
            font-size: 10px;
            color: #666;
            padding: 3px 0;
            background: #eaeaea;
            border-bottom: 1px solid #ddd;
        }
        .year-day { position: relative; height: 22px; border-right: 1px solid #eee; border-bottom: 1px solid #eee; background: #fff; }
        .year-day.other-month { background: #fafafa; }
        .year-day-number { position: absolute; top: 2px; left: 2px; font-size: 10px; color: #333; z-index: 2; }

        /* (Revertido) estilos de vista anual eliminados */

        .day-events {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 1px;
            margin-top: 16px;
            padding: 2px;
        }

        .event-badge {
            font-size: 7px;
            padding: 1px 2px;
            border-radius: 2px;
            background: #e3f2fd;
            color: #1976d2;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.1;
        }

        .event-dot {
            width: 6px;
            height: 6px;
            border-radius: 3px;
            background: #1976d2;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: flex-start;
            justify-content: center;
            padding: 10px;
            overflow-y: auto;
        }

        .modal.show {
            display: flex;
        }

        /* Estilos para el modal - Réplica exacta de las fotos */
        .modal-content-exact {
            background: white;
            width: 100%;
            max-width: 500px;
            min-height: 100vh;
            border-radius: 0;
            overflow: hidden;
            box-shadow: none;
            margin: 0 auto;
            padding: 0;
        }

        /* Top Blue Header */
        .modal-header-blue {
            background: #2196F3;
            color: white;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .back-arrow {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-date {
            font-size: 18px;
            font-weight: bold;
            flex: 1;
            text-align: center;
        }

        .header-spacer {
            width: 30px;
        }

        /* Main Content Card */
        .main-content-card {
            background: white;
            margin: 0;
            padding: 20px;
            border-radius: 0;
            box-shadow: none;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .document-icon {
            font-size: 20px;
            color: #666;
            margin-top: 4px;
        }

        .main-textarea {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 12px;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            min-height: 80px;
            outline: none;
        }

        .main-textarea::placeholder {
            color: #999;
        }

        /* Alarm Section */
        .alarm-section {
            background: white;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .alarm-section:active {
            background-color: #f5f5f5;
        }

        .alarm-icon {
            font-size: 24px;
            color: #f44336;
        }

        .alarm-text {
            flex: 1;
            font-size: 16px;
            font-weight: bold;
            color: #f44336;
        }

        .alarm-number {
            background: #FF9800;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }

        /* Modal de configuración de alarma */
        .alarm-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .alarm-modal.show {
            display: flex;
        }

        .alarm-modal-content {
            background: white;
            width: 100%;
            max-width: 400px;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .alarm-modal-header {
            background: #FF9800;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 16px 16px 0 0;
        }

        .alarm-modal-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .alarm-modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .alarm-modal-body {
            padding: 20px;
        }

        .alarm-input-group {
            margin-bottom: 20px;
        }

        .alarm-input-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
        }

        .alarm-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            outline: none;
        }

        .alarm-input:focus {
            border-color: #FF9800;
        }

        .alarm-list {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .alarm-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .alarm-item:last-child {
            border-bottom: none;
        }

        .alarm-item-info {
            flex: 1;
        }

        .alarm-item-date {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .alarm-item-time {
            color: #666;
            font-size: 12px;
            margin-top: 4px;
        }

        .alarm-item-delete {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
        }

        /* Day Shifts Section */
        .shifts-card {
            background: white;
            margin: 0;
            padding: 20px;
            border-radius: 0;
            box-shadow: none;
            border-bottom: 1px solid #f0f0f0;
        }

        .shifts-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 16px;
        }

        .shifts-content {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
            width: 100%;
        }

        .clock-icon {
            font-size: 48px;
            color: #ccc;
        }

        .no-shifts-text {
            color: #999;
            font-size: 14px;
        }

        /* Shift Display Styles */
        .shift-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: #E8F5E8;
            border: 1px solid #4CAF50;
            border-radius: 6px;
            margin: 4px 0;
            width: 100%;
            box-sizing: border-box;
        }

        .shift-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4CAF50;
        }

        .shift-name {
            font-size: 14px;
            color: #2E7D32;
            font-weight: 500;
        }

        /* Categories Section */
        .categories-card {
            background: white;
            margin: 0;
            padding: 20px;
            border-radius: 0;
            box-shadow: none;
            border-bottom: 1px solid #f0f0f0;
        }

        .categories-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 16px;
        }

        .categories-dropdowns {
            display: flex;
            gap: 8px;
            width: 100%;
        }

        .category-dropdown {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            min-width: 0;
            position: relative;
        }

        .no-icon {
            font-size: 12px;
            color: #999;
        }

        .dropdown-text {
            flex: 1;
            font-size: 11px;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dropdown-arrow {
            font-size: 10px;
            color: #999;
        }

        /* Dropdown Options */
        .dropdown-options {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            max-height: none;
            overflow-y: visible;
            display: none;
            min-width: 120px;
            margin-bottom: 4px;
        }

        .dropdown-options.show {
            display: block;
        }

        .dropdown-option {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 11px;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
        }

        .dropdown-option:hover {
            background-color: #f5f5f5;
        }

        .dropdown-option:last-child {
            border-bottom: none;
        }

        .dropdown-option-icon {
            font-size: 10px;
            width: 14px;
            text-align: center;
        }

        .dropdown-option-text {
            font-size: 10px;
            color: #333;
            white-space: nowrap;
        }

        /* Action Buttons */
        .action-buttons {
            background: #f5f5f5;
            padding: 20px;
            display: flex;
            gap: 12px;
            margin-top: auto;
        }

        .btn-cancel, .btn-accept {
            flex: 1;
            padding: 14px 20px;
            border: 2px solid;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-cancel {
            background: white;
            border-color: #f44336;
            color: #f44336;
        }

        .btn-cancel:hover {
            background: #f44336;
            color: white;
        }

        .btn-accept {
            background: white;
            border-color: #4CAF50;
            color: #4CAF50;
        }

        .btn-accept:hover {
            background: #4CAF50;
            color: white;
        }

        /* Media queries para pantallas pequeñas */
        @media (max-width: 480px) {
            .modal-content-exact {
                max-width: 100%;
                margin: 0;
            }
            
            .categories-dropdowns {
                gap: 4px;
            }
            
            .category-dropdown {
                padding: 6px 4px;
                gap: 2px;
            }
            
            .dropdown-text {
                font-size: 10px;
            }
            
            .no-icon {
                font-size: 10px;
            }
            
            .dropdown-arrow {
                font-size: 8px;
            }
        }

        /* Modal de Notas - Réplica exacta de la imagen */
        .notes-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .notes-modal:not(.show) {
            pointer-events: none;
        }

        .notes-modal.show {
            display: flex;
        }

        .notes-modal-content {
            background: white;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
        }
        
        /* Contenedor scrollable para el contenido */
        .notes-modal-scrollable {
            overflow-y: auto;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Cerrar modal al hacer clic fuera */
        .notes-modal.show .notes-modal-content {
            pointer-events: auto;
        }

        .notes-modal.show::before {
            content: '';
            position: absolute;
            inset: 0;
            z-index: 0;
        }

        /* Header rojo */
        .notes-header {
            background: #f44336;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 16px 16px 0 0;
        }

        .notes-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .notes-share-icon {
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        /* Campo de texto */
        .notes-input-container {
            padding: 20px;
            background: white;
            flex-shrink: 0;
        }

        .notes-textarea {
            width: 100%;
            min-height: 150px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            outline: none;
            background: white;
        }

        /* Div editable para formato de texto */
        .notes-content-editable {
            width: 100%;
            min-height: 150px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            font-size: 16px;
            font-family: inherit;
            outline: none;
            background: white;
            overflow-y: auto;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .notes-content-editable:empty:before {
            content: attr(data-placeholder);
            color: #999;
        }

        .notes-content-editable:focus {
            border-color: #2196F3;
        }

        /* Control de tamaño de texto */
        .notes-text-size-container {
            padding: 0 20px 16px;
            background: white;
            flex-shrink: 0;
        }

        .notes-text-size-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
        }

        .notes-text-size-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .notes-text-size-value {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            min-width: 30px;
            text-align: center;
        }

        .notes-text-size-slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .notes-text-size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00BCD4;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .notes-text-size-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00BCD4;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Botones de formato */
        .notes-format-buttons {
            display: flex;
            gap: 12px;
            padding: 0 20px 16px;
            justify-content: center;
            flex-shrink: 0;
        }

        .format-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid #00BCD4;
            background: white;
            color: #333;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .format-btn.active {
            background: #00BCD4;
            color: white;
            border-color: #00BCD4;
        }

        .format-btn:active {
            transform: scale(0.95);
        }

        /* Botones de acción */
        .notes-action-buttons {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex-shrink: 0;
            background: white;
            border-top: 1px solid #f0f0f0;
        }

        .action-buttons-row {
            display: flex;
            gap: 12px;
        }

        .action-btn {
            padding: 12px 20px;
            border: 2px solid;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
        }

        .delete-btn {
            background: white;
            border: 2px solid #333;
            color: #333;
            width: 100%;
            display: block;
            font-weight: bold;
        }

        .delete-btn:hover {
            background: #f5f5f5;
        }

        .delete-btn:active {
            background: #333;
            color: white;
        }

        .cancel-btn {
            background: white;
            border: 2px solid #f44336;
            color: #f44336;
            display: block;
            min-width: 100px;
            font-weight: bold;
        }

        .cancel-btn:hover {
            background: #f44336;
            color: white;
        }

        .cancel-btn:active {
            background: #d32f2f;
            border-color: #d32f2f;
            color: white;
        }

        .accept-btn {
            background: white;
            border: 2px solid #4CAF50;
            color: #4CAF50;
            display: block;
            min-width: 100px;
            font-weight: bold;
        }

        .accept-btn:hover {
            background: #4CAF50;
            color: white;
        }

        .accept-btn:active {
            background: #388E3C;
            border-color: #388E3C;
            color: white;
        }

        .action-buttons-row {
            display: flex;
            gap: 12px;
            width: 100%;
        }

        .action-buttons-row .action-btn {
            flex: 1;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 24px;
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #1B5E20;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .modal-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #666;
        }

        .event-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .event-item {
            padding: 12px;
            background: #f5f5f5;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .event-text {
            flex: 1;
            font-size: 14px;
        }

        .event-user {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }

        .delete-btn {
            background: #f44336;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            color: white;
            font-size: 12px;
            cursor: pointer;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-field {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
        }

        .btn-primary {
            background: #1B5E20;
            border: none;
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-primary:active {
            background: #2E7D32;
        }

        .empty-message {
            text-align: center;
            color: #999;
            font-style: italic;
            padding: 20px;
        }

        /* Bottom Info */
        .bottom-info {
            background: white;
            padding: 3px 12px;
            text-align: center;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
            min-height: 20px;
        }

        .current-user-info {
            font-size: 9px;
            color: #666;
        }

        /* Bottom Action Buttons */
        .bottom-actions {
            background: white;
            padding: 0;
            display: flex !important;
            gap: 0;
            flex-shrink: 0;
            min-height: 40px;
            position: relative;
            z-index: 2000 !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .action-btn {
            flex: 1;
            border: none;
            border-radius: 0;
            padding: 10px 6px;
            color: white;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .action-btn:active {
            opacity: 0.8;
            transform: scale(0.98);
        }

        .action-btn.pintar {
            background: #FF9800;
        }

        .action-btn.editar {
            background: #2196F3;
        }

        .action-btn.turnos {
            background: #4CAF50;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
            display: none !important;
        }

        .connection-status.connected {
            background: #4CAF50;
            color: white;
        }

        .connection-status.disconnected {
            background: #FF9800;
            color: white;
        }

        .connection-status.error {
            background: #F44336;
            color: white;
        }

        /* Pop-up de Selección de Turnos */
        .shifts-popup {
            position: fixed;
            bottom: 0 !important;
            left: 0;
            right: 0;
            background: white;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1900 !important;
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            display: none !important;
            flex-direction: row;
            align-items: center;
            padding: 4px 8px;
            min-height: 52px;
        }

        .shifts-popup.show {
            display: flex !important;
            transform: translateY(0);
            z-index: 2100 !important;
        }

        /* Ocultar barra de botones cuando el pop-up está abierto */
        .shifts-popup.show ~ .bottom-actions {
            display: none !important;
        }

        .shifts-popup-header {
            display: none;
        }

        .shifts-popup-close {
            background: none;
            border: none;
            font-size: 18px;
            color: #666;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .shifts-popup-close:active {
            background: #f0f0f0;
        }

        .shifts-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            flex-direction: row;
            gap: 8px;
            flex-wrap: nowrap;
            flex: 1;
            white-space: nowrap;
            padding: 0;
        }

        .shift-button-paint {
            min-width: 40px;
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            color: white;
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
        }

        .shift-button-paint:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .shift-button-paint:hover {
            opacity: 0.9;
        }

        /* Color por defecto para turnos sin color especificado */
        .shift-button-paint.default {
            background: #9E9E9E;
        }

        /* Botón de borrar turnos */
        .shift-button-delete {
            min-width: 40px;
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 50%;
            border: 2px solid #f44336;
            cursor: pointer;
            font-size: 20px;
            font-weight: normal;
            color: #f44336;
            background: white;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .shift-button-delete:active {
            transform: scale(0.95);
            background: #f44336;
            color: white;
        }

        .shift-button-delete:hover {
            background: #f44336;
            color: white;
        }

    </style>
</head>
<body>
    

    <!-- Header -->
    <div class="header">
        <div class="header-title">My Calendar</div>
        <div class="header-actions">
            <button class="header-btn" onclick="goBack()">👤</button>
            <button class="menu-btn" onclick="openSettings()">⚙️</button>
        </div>
    </div>

    <!-- Tab Navigation -->
    <div class="tab-nav">
        <button class="tab-btn active" onclick="showTab('calendar')">Calendario</button>
        <button class="tab-btn" onclick="showTab('year')">2025</button>
        <button class="tab-btn" onclick="showTab('summary')">Resumen</button>
    </div>

    <!-- Month Navigation -->
    <div class="month-nav">
        <button onclick="changeMonth(-1)">‹</button>
        <div class="month-title" id="monthTitle"></div>
        <button onclick="changeMonth(1)">›</button>
    </div>

    <!-- Calendar -->
    <div class="calendar-container">
        <div class="calendar-grid" id="calendarGrid">
            <!-- Se carga dinámicamente -->
        </div>
    </div>

        <!-- Year View (anual) -->
        <div class="calendar-container" id="yearView" style="display: none;">
            <div class="year-nav">
                <button onclick="changeYear(-1)">‹</button>
                <div class="title" id="yearTitle">2025</div>
                <button onclick="changeYear(1)">›</button>
            </div>
            <div class="year-grid" id="yearGrid"></div>
        </div>

        

    <!-- Bottom Info -->
    <div class="bottom-info" style="display: none;">
        <div class="current-user-info" id="currentUserInfo"></div>
    </div>

    <!-- Bottom Action Buttons -->
    <div class="bottom-actions">
        <button class="action-btn pintar" onclick="activatePaintMode()">PINTAR</button>
        <button class="action-btn editar" onclick="activateEditMode()">EDITAR</button>
        <button class="action-btn turnos" onclick="showShifts()">TURNOS</button>
    </div>

    <!-- Settings Modal -->
    <div class="settings-backdrop" id="settingsModal">
        <div class="settings-panel" onclick="event.stopPropagation()">
            <div class="settings-header">
                <div class="settings-title">Configuración</div>
                <button class="btn btn-secondary" onclick="closeSettings()">Cerrar</button>
            </div>
            <div class="settings-group">
                <div class="settings-row">
                    <div class="settings-label">Tema</div>
                    <select id="stTheme" class="settings-select">
                        <option value="system">Sistema</option>
                        <option value="light">Claro</option>
                        <option value="dark">Oscuro</option>
                    </select>
                </div>
                <div class="settings-row">
                    <div class="settings-label">Inicio de semana</div>
                    <select id="stWeekStart" class="settings-select">
                        <option value="monday">Lunes</option>
                        <option value="sunday">Domingo</option>
                    </select>
                </div>
                <div class="settings-row">
                    <div class="settings-label">Resaltar día de hoy en rojo</div>
                    <input id="stHighlightToday" type="checkbox" class="settings-checkbox" />
                </div>
                <div class="settings-row">
                    <div class="settings-label">Sexta semana solo si es necesaria</div>
                    <input id="stSmartWeeks" type="checkbox" class="settings-checkbox" />
                </div>
            </div>
            <div class="settings-group">
                <div class="settings-row">
                    <div class="settings-label">Abrir Resumen</div>
                    <button class="btn btn-secondary" onclick="window.location.href='summary.html'">Ir</button>
                </div>
                <div class="settings-row">
                    <div class="settings-label">Abrir 2025</div>
                    <button class="btn btn-secondary" onclick="showTab('year')">Ir</button>
                </div>
                <div class="settings-row">
                    <div class="settings-label">Copias de seguridad</div>
                    <div class="settings-actions">
                        <button class="btn btn-secondary" onclick="window.location.href='firestore_backup.html'">Backup</button>
                        <button class="btn btn-secondary" onclick="window.location.href='firestore_cleanup.html'">Herramientas</button>
                    </div>
                </div>
            </div>
            <div class="settings-actions">
                <button class="btn btn-primary" onclick="saveSettings()">Guardar</button>
                <button class="btn btn-secondary" onclick="resetSettings()">Restablecer</button>
            </div>
        </div>
    </div>

    <!-- Pop-up de Selección de Turnos para Pintar -->
    <div class="shifts-popup" id="shiftsPopup" hidden>
        <button class="shifts-popup-close" onclick="closeShiftsPopup()">⌄</button>
        <div class="shifts-scroll" id="shiftsScroll">
            <!-- Se carga dinámicamente -->
        </div>
    </div>

    <!-- Modal for Day Details - Réplica exacta de las fotos -->
    <div class="modal" id="dayModal">
        <div class="modal-content-exact">
            <!-- Top Blue Header -->
            <div class="modal-header-blue">
                <div class="header-date" id="modalDate">8/10/25</div>
            </div>

            <!-- Main Content Card -->
            <div class="main-content-card">
                <div class="document-icon">📄+</div>
                <textarea class="main-textarea" placeholder="Añadir nota..." id="mainTextarea" onclick="openNotesPopup()" style="cursor: pointer;"></textarea>
            </div>

            <!-- Alarm Section -->
            <div class="alarm-section" onclick="openAlarmModal()">
                <div class="alarm-icon">🔔</div>
                <div class="alarm-text">Aviso de Alarma</div>
                <div class="alarm-number" id="alarmNumber">0</div>
            </div>

            <!-- Day Shifts Section -->
            <div class="shifts-card">
                <div class="shifts-title">Turnos del día</div>
                <div class="shifts-content" id="shiftsContent">
                    <div class="clock-icon">🕐</div>
                    <div class="no-shifts-text">No hay turnos asignados</div>
                </div>
            </div>

            <!-- Categories Section -->
            <div class="categories-card">
                <div class="categories-title">Categorías</div>
                <div class="categories-dropdowns">
                    <div class="category-dropdown" onclick="toggleDropdown(0)">
                        <div class="no-icon">🚫</div>
                        <span class="dropdown-text">Ninguno</span>
                        <span class="dropdown-arrow">▼</span>
                        <div class="dropdown-options" id="dropdown-0">
                            <div class="dropdown-option" onclick="selectCategory(0, 'Ninguno', '')">
                                <div class="dropdown-option-icon"></div>
                                <div class="dropdown-option-text">Ninguno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Cambio de turno', '🔄')">
                                <div class="dropdown-option-icon">🔄</div>
                                <div class="dropdown-option-text">Cambio de turno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Ingreso', '$')">
                                <div class="dropdown-option-icon">$</div>
                                <div class="dropdown-option-text">Ingreso</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Importante', '⚠️')">
                                <div class="dropdown-option-icon">⚠️</div>
                                <div class="dropdown-option-text">Importante</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Festivo', '☀️')">
                                <div class="dropdown-option-icon">☀️</div>
                                <div class="dropdown-option-text">Festivo</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Médico', '🩺')">
                                <div class="dropdown-option-icon">🩺</div>
                                <div class="dropdown-option-text">Médico</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Mascota', '🐱')">
                                <div class="dropdown-option-icon">🐱</div>
                                <div class="dropdown-option-text">Mascota</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Favorito', '⭐')">
                                <div class="dropdown-option-icon">⭐</div>
                                <div class="dropdown-option-text">Favorito</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Coche', '🚗')">
                                <div class="dropdown-option-icon">🚗</div>
                                <div class="dropdown-option-text">Coche</div>
                            </div>
                        </div>
                    </div>
                    <div class="category-dropdown" onclick="toggleDropdown(1)">
                        <div class="no-icon">🚫</div>
                        <span class="dropdown-text">Ninguno</span>
                        <span class="dropdown-arrow">▼</span>
                        <div class="dropdown-options" id="dropdown-1">
                            <div class="dropdown-option" onclick="selectCategory(1, 'Ninguno', '')">
                                <div class="dropdown-option-icon"></div>
                                <div class="dropdown-option-text">Ninguno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Cambio de turno', '🔄')">
                                <div class="dropdown-option-icon">🔄</div>
                                <div class="dropdown-option-text">Cambio de turno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Ingreso', '$')">
                                <div class="dropdown-option-icon">$</div>
                                <div class="dropdown-option-text">Ingreso</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Importante', '⚠️')">
                                <div class="dropdown-option-icon">⚠️</div>
                                <div class="dropdown-option-text">Importante</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Festivo', '☀️')">
                                <div class="dropdown-option-icon">☀️</div>
                                <div class="dropdown-option-text">Festivo</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Médico', '🩺')">
                                <div class="dropdown-option-icon">🩺</div>
                                <div class="dropdown-option-text">Médico</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Mascota', '🐱')">
                                <div class="dropdown-option-icon">🐱</div>
                                <div class="dropdown-option-text">Mascota</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Favorito', '⭐')">
                                <div class="dropdown-option-icon">⭐</div>
                                <div class="dropdown-option-text">Favorito</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Coche', '🚗')">
                                <div class="dropdown-option-icon">🚗</div>
                                <div class="dropdown-option-text">Coche</div>
                            </div>
                        </div>
                    </div>
                    <div class="category-dropdown" onclick="toggleDropdown(2)">
                        <div class="no-icon">🚫</div>
                        <span class="dropdown-text">Ninguno</span>
                        <span class="dropdown-arrow">▼</span>
                        <div class="dropdown-options" id="dropdown-2">
                            <div class="dropdown-option" onclick="selectCategory(2, 'Ninguno', '')">
                                <div class="dropdown-option-icon"></div>
                                <div class="dropdown-option-text">Ninguno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Cambio de turno', '🔄')">
                                <div class="dropdown-option-icon">🔄</div>
                                <div class="dropdown-option-text">Cambio de turno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Ingreso', '$')">
                                <div class="dropdown-option-icon">$</div>
                                <div class="dropdown-option-text">Ingreso</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Importante', '⚠️')">
                                <div class="dropdown-option-icon">⚠️</div>
                                <div class="dropdown-option-text">Importante</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Festivo', '☀️')">
                                <div class="dropdown-option-icon">☀️</div>
                                <div class="dropdown-option-text">Festivo</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Médico', '🩺')">
                                <div class="dropdown-option-icon">🩺</div>
                                <div class="dropdown-option-text">Médico</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Mascota', '🐱')">
                                <div class="dropdown-option-icon">🐱</div>
                                <div class="dropdown-option-text">Mascota</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Favorito', '⭐')">
                                <div class="dropdown-option-icon">⭐</div>
                                <div class="dropdown-option-text">Favorito</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Coche', '🚗')">
                                <div class="dropdown-option-icon">🚗</div>
                                <div class="dropdown-option-text">Coche</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="btn-cancel" onclick="closeModal()">CANCELAR</button>
                <button class="btn-accept" onclick="acceptDayChanges()">ACEPTAR</button>
            </div>
        </div>
    </div>

    <!-- Modal de Notas - Réplica exacta de la imagen -->
    <div class="notes-modal" id="notesModal" onclick="handleNotesModalClick(event)">
        <div class="notes-modal-content" onclick="event.stopPropagation()">
            <!-- Header rojo -->
            <div class="notes-header">
                <div class="notes-title">NOTAS</div>
                <div class="notes-share-icon">🔗</div>
            </div>
            
            <!-- Campo de texto -->
            <div class="notes-input-container">
                <div class="notes-content-editable" id="notesTextarea" contenteditable="true" data-placeholder="Notas del día..."></div>
            </div>
            
            <!-- Botones de formato -->
            <div class="notes-format-buttons">
                <button class="format-btn" id="formatBold" onclick="toggleFormat('bold')">B</button>
                <button class="format-btn" id="formatItalic" onclick="toggleFormat('italic')">I</button>
                <button class="format-btn" id="formatUnderline" onclick="toggleFormat('underline')">U</button>
            </div>
            
            <!-- Control de tamaño de texto -->
            <div class="notes-text-size-container">
                <label class="notes-text-size-label">Tamaño del texto en celdas:</label>
                <div class="notes-text-size-control">
                    <span class="notes-text-size-value" id="notesTextSizeValue">11</span>
                    <input type="range" id="notesTextSizeSlider" min="8" max="16" value="11" step="1" oninput="updateNotesTextSize(this.value)" class="notes-text-size-slider">
                </div>
            </div>
            
            <!-- Botones de acción -->
            <div class="notes-action-buttons">
                <button class="action-btn delete-btn" onclick="deleteNote()">BORRAR</button>
                <div class="action-buttons-row" style="display: flex !important; gap: 12px; width: 100%;">
                    <button class="action-btn cancel-btn" onclick="cancelNotesPopup()" style="flex: 1; background: white; border: 2px solid #f44336; color: #f44336; padding: 12px 20px; border-radius: 8px; font-weight: bold; cursor: pointer;">CANCELAR</button>
                    <button class="action-btn accept-btn" onclick="acceptNotesPopup()" style="flex: 1; background: white; border: 2px solid #4CAF50; color: #4CAF50; padding: 12px 20px; border-radius: 8px; font-weight: bold; cursor: pointer;">ACEPTAR</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Configuración de Alarma -->
    <div class="alarm-modal" id="alarmModal" onclick="handleAlarmModalClick(event)">
        <div class="alarm-modal-content" onclick="event.stopPropagation()">
            <!-- Header naranja -->
            <div class="alarm-modal-header">
                <div class="alarm-modal-title">Configurar Alarma</div>
                <button class="alarm-modal-close" onclick="closeAlarmModal()">×</button>
            </div>
            
            <!-- Contenido -->
            <div class="alarm-modal-body">
                <div class="alarm-input-group">
                    <label class="alarm-input-label">Fecha:</label>
                    <input type="date" id="alarmDateInput" class="alarm-input" />
                </div>
                
                <div class="alarm-input-group">
                    <label class="alarm-input-label">Hora:</label>
                    <input type="time" id="alarmTimeInput" class="alarm-input" />
                </div>
                
                <div class="action-buttons-row" style="display: flex !important; gap: 12px; width: 100%; margin-top: 20px;">
                    <button class="action-btn accept-btn" onclick="addAlarm()" style="flex: 1; background: white; border: 2px solid #4CAF50; color: #4CAF50; padding: 12px 20px; border-radius: 8px; font-weight: bold; cursor: pointer;">AGREGAR</button>
                </div>
                
                <!-- Lista de alarmas existentes -->
                <div class="alarm-list" id="alarmList">
                    <!-- Las alarmas se cargarán aquí -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Estado global
        let currentDate = new Date();
        let currentUserId = 1;
        let selectedDate = null;
        let db = null;
        let isFirebaseConnected = false;
        let users = [];
        let shiftTemplates = [];

        // Configuración de Firebase (configuración real del proyecto)
        const firebaseConfig = {
            apiKey: "AIzaSyB5vvp7IQOZLO7LlsUY_Wq-H8M_5PH3ZQE",
            authDomain: "apptaxi-f2190.firebaseapp.com",
            projectId: "apptaxi-f2190",
            storageBucket: "apptaxi-f2190.firebasestorage.app",
            messagingSenderId: "804273724178",
            appId: "1:804273724178:web:c5955a1f657884c0e7f1cb",
            measurementId: "G-3D8R30TYTM"
        };

        const monthNames = [
            'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
            'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
        ];

        // Días de la semana (se obtiene dinámicamente según configuración)
        function weekDays(){ return getWeekDays(); }

        // Variables globales
        let isRendering = false;
        let renderTimeout = null;
        let lastRenderTime = 0;
        let eventsCache = {}; // Cache de eventos para evitar múltiples llamadas a Firebase

        

        // Inicializar Firebase
        async function initFirebase() {
            try {
                // Inicializar Firebase
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                isFirebaseConnected = true;
                console.log('✅ Firebase conectado correctamente');
                
                
                // Cargar usuarios desde Firebase
                await loadUsersFromFirebase();
                
                // Cargar shift templates
                loadShiftTemplates();
                
                // Configurar listener para cambios en tiempo real
                setupRealtimeListener();
                
                return true;
            } catch (error) {
                console.error('❌ Error conectando Firebase:', error);
                isFirebaseConnected = false;
                
                // Usar usuarios por defecto si Firebase falla
                loadDefaultUsers();
                return false;
            }
        }

        // Cargar usuarios desde Firebase
        async function loadUsersFromFirebase() {
            try {
                const snapshot = await db.collection('users').get();
                
                if (snapshot.empty) {
                    console.log('⚠️ No hay usuarios en Firebase, usando usuarios por defecto');
                    loadDefaultUsers();
                    await saveUsersToFirebase();
                } else {
                    users = snapshot.docs.map(doc => {
                        const data = doc.data();
                        return {
                            id: parseInt(data.id) || parseInt(doc.id),
                            name: data.name || `Usuario ${doc.id}`,
                            color: data.color || '#9E9E9E'
                        };
                    });
                    console.log('✅ Usuarios cargados desde Firebase:', users.length, users);
                }
            } catch (error) {
                console.error('❌ Error cargando usuarios:', error);
                loadDefaultUsers();
            }
        }

        // Cargar usuarios por defecto
        function loadDefaultUsers() {
            users = [
                { id: 1, name: 'Usuario 1', color: '#2196F3' },
                { id: 2, name: 'Usuario 2', color: '#4CAF50' },
                { id: 3, name: 'Usuario 3', color: '#FF9800' },
                { id: 4, name: 'Usuario 4', color: '#9C27B0' }
            ];
        }

        // Guardar usuarios en Firebase
        async function saveUsersToFirebase() {
            if (!isFirebaseConnected) return;

            try {
                for (const user of users) {
                    await db.collection('users').doc(user.id.toString()).set({
                        id: user.id,
                        name: user.name,
                        color: user.color,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                console.log('✅ Usuarios guardados en Firebase');
            } catch (error) {
                console.error('❌ Error guardando usuarios:', error);
            }
        }

        // Cargar shift templates desde Firebase
        async function loadShiftTemplates() {
            if (!isFirebaseConnected) return;
            
            try {
                    const snapshot = await db.collection('shifts').get();
                shiftTemplates = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                console.log('✅ Shift templates cargados:', shiftTemplates.length);
            } catch (error) {
                console.error('❌ Error cargando shift templates:', error);
                // Usar templates por defecto si falla
                shiftTemplates = [
                    { id: '1', name: 'D1', colorHex: '#FF5722', abbreviation: 'D1' },
                    { id: '2', name: 'D2', colorHex: '#4CAF50', abbreviation: 'D2' },
                    { id: '3', name: 'N1', colorHex: '#9C27B0', abbreviation: 'N1' },
                    { id: '4', name: 'Libre', colorHex: '#607D8B', abbreviation: 'Lib' },
                    { id: '5', name: 'Tarde', colorHex: '#FF9800', abbreviation: 'T' },
                    { id: '6', name: 'Mañana', colorHex: '#2196F3', abbreviation: 'M' }
                ];
            }
        }

        // Configurar listener en tiempo real
        function setupRealtimeListener() {
            if (!isFirebaseConnected) return;
            
            // Listener SOLO para shifts: si se edita un turno (nombre/color/abreviatura),
            // actualizamos plantillas y re-renderizamos el calendario.
            db.collection('shifts').onSnapshot((snapshot) => {
                console.log('🔄 Cambios detectados en shifts');
                shiftTemplates = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                scheduleRenderCalendar();
            }, (error) => {
                console.error('❌ Error en listener de shifts:', error);
            });

            // Listener para eventos del calendario: actualizar caché por doc cambiado
            db.collection('calendar_events').onSnapshot((snapshot) => {
                if (!eventsCache.events) eventsCache.events = {};
                snapshot.docChanges().forEach(change => {
                    const id = change.doc.id; // dateKey YYYY-MM-DD
                    const data = change.doc.data();
                    if (change.type === 'removed') {
                        eventsCache.events[id] = [];
                    } else {
                        eventsCache.events[id] = data?.events || [];
                    }
                });
                // Refrescar vistas activas
                scheduleRenderCalendar();
                const yearView = document.getElementById('yearView');
                if (yearView && yearView.style.display !== 'none') {
                    renderYear();
                }
            }, (error) => {
                console.error('❌ Error en listener de calendar_events:', error);
            });
        }

        // Inicializar
        async function init() {
            console.log('📅 Inicializando calendario...');
            // Aplicar tema y configuración persistida
            applySettings();
            
            
            // Cargar usuario guardado
            const savedUserId = localStorage.getItem('current_user_id');
            if (savedUserId) {
                currentUserId = parseInt(savedUserId);
            }

            // Intentar conectar Firebase
            if (!(await initFirebase())) {
                
            }

            // Agregar algunos eventos de prueba
            addTestEvents();

            // Soporte de salto desde Resumen: ajustar mes/día si hay 'jump_to_date'
            const jump = localStorage.getItem('jump_to_date');
            if (jump) {
                try {
                    const [y,m,d]=jump.split('-').map(Number);
                    currentDate = new Date(y, m-1, d);
                } catch(e) { console.warn('jump_to_date inválido', e); }
                localStorage.removeItem('jump_to_date');
            }

            // Asegurar que el tab de calendario esté activo al iniciar
            ensureCalendarTabActive();
            
            // Renderizar calendario solo una vez
            setTimeout(() => {
                renderCalendar();
                updateCurrentUserInfo();
                // Abrir modal si se solicitó salto exacto a día
                if (jump) {
                    const [y,m,d]=jump.split('-').map(Number);
                    const dt = new Date(y, m-1, d);
                    setTimeout(()=>openDayModal(dt), 300);
                }
            }, 100);
            
            // Solicitar permiso para notificaciones al iniciar
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    console.log('📱 Permiso de notificaciones:', permission);
                });
            }
            
            // Registrar Service Worker para alarmas (no funciona bien en iOS cuando la app está cerrada)
            if ('serviceWorker' in navigator && !isIOS) {
                navigator.serviceWorker.register('sw-alarm.js')
                    .then((registration) => {
                        console.log('✅ Service Worker registrado para alarmas:', registration.scope);
                    })
                    .catch((error) => {
                        console.error('❌ Error registrando Service Worker:', error);
                    });
            } else if (isIOS) {
                console.log('ℹ️ iOS detectado: Service Worker tiene limitaciones, usando verificación local');
            }
            
            // Escuchar mensajes del Service Worker
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'OPEN_ALARM') {
                        window.location.href = event.data.url;
                    } else if (event.data && event.data.type === 'SHOW_ALARM') {
                        // Mostrar la pantalla de alarma cuando el Service Worker no puede abrir ventana
                        const { url, date, time, note, user } = event.data;
                        openAlarmNotificationPage(date, time, note);
                    }
                });
            }
            
            // Guardar alarmas en localStorage para verificación cuando la app se abre (especialmente para iOS)
            saveAlarmsToLocalStorage();
            
            // Verificar alarmas pendientes al abrir la app
            checkPendingAlarmsOnStart();
            
            // Detectar cuando la app vuelve al primer plano (importante para iOS)
            setupVisibilityChangeListener();
            
            // Detectar cuando la app se convierte en PWA instalada
            checkPWAInstallation();
            
            // Iniciar verificación de alarmas después de un breve delay
            setTimeout(() => {
                setupAlarmNotifications();
                if (!isIOS) {
                    scheduleAllAlarms(); // Programar todas las alarmas existentes en Service Worker
                } else {
                    // En iOS, programar alarmas en localStorage para verificación periódica
                    scheduleAlarmsForIOS();
                }
            }, 2000);
        }

        // Configuración
        const SETTINGS_KEY = 'app_settings_v1';
        function loadSettings(){
            try { return JSON.parse(localStorage.getItem(SETTINGS_KEY)) || { theme:'system', weekStart:'monday', highlightToday:true, smartWeeks:true }; } catch(e){ return { theme:'system', weekStart:'monday', highlightToday:true, smartWeeks:true }; }
        }
        function saveSettings(){
            const st = loadSettings();
            st.theme = document.getElementById('stTheme').value;
            st.weekStart = document.getElementById('stWeekStart').value;
            st.highlightToday = document.getElementById('stHighlightToday').checked;
            st.smartWeeks = document.getElementById('stSmartWeeks').checked;
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(st));
            applySettings();
            closeSettings();
            // Re-render para aplicar semana y estilos
            renderCalendar(true);
        }
        function resetSettings(){ localStorage.removeItem(SETTINGS_KEY); applySettings(); closeSettings(); renderCalendar(true); }
        function openSettings(){
            const st = loadSettings();
            document.getElementById('stTheme').value = st.theme||'system';
            document.getElementById('stWeekStart').value = st.weekStart||'monday';
            document.getElementById('stHighlightToday').checked = st.highlightToday!==false;
            document.getElementById('stSmartWeeks').checked = st.smartWeeks!==false;
            document.getElementById('settingsModal').classList.add('show');
        }
        function closeSettings(ev){ if (ev && ev.target && !ev.target.classList){} document.getElementById('settingsModal').classList.remove('show'); }
        function applySettings(){
            const st = loadSettings();
            // Tema
            if (st.theme==='dark') document.documentElement.style.colorScheme='dark';
            else if (st.theme==='light') document.documentElement.style.colorScheme='light';
            else document.documentElement.style.colorScheme='normal';
        }
        // Utilidad: días de la semana según configuración
        function getWeekDays(){
            const st = loadSettings();
            const base = ['Lun','Mar','Mié','Jue','Vie','Sáb','Dom'];
            if (st.weekStart==='sunday') return ['Dom','Lun','Mar','Mié','Jue','Vie','Sáb'];
            return base;
        }

        // Asegurar que el tab de calendario esté activo
        function ensureCalendarTabActive() {
            // Verificar parámetros de URL que puedan cambiar el tab
            const urlParams = new URLSearchParams(window.location.search);
            const tabParam = urlParams.get('tab');
            
            // Si hay un parámetro tab=summary, eliminarlo y quedarse en calendario
            if (tabParam === 'summary') {
                // Limpiar parámetro y redirigir a calendario limpio
                const newUrl = window.location.pathname;
                window.history.replaceState({}, '', newUrl);
            }
            
            // Asegurar que el tab de calendario esté visible
            const calendarBtn = document.querySelector('.tab-btn[onclick*="calendar"]');
            const yearBtn = document.querySelector('.tab-btn[onclick*="year"]');
            const summaryBtn = document.querySelector('.tab-btn[onclick*="summary"]');
            
            // Remover active de todos
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Activar solo el de calendario
            if (calendarBtn) {
                calendarBtn.classList.add('active');
            }
            
            // Mostrar calendario y ocultar año
            const mainGridContainer = document.querySelector('.calendar-container');
            const yearView = document.getElementById('yearView');
            const monthNav = document.querySelector('.month-nav');
            
            if (monthNav) monthNav.style.display = 'flex';
            if (yearView) yearView.style.display = 'none';
            if (mainGridContainer) mainGridContainer.style.display = 'block';
        }
        
        // Mostrar tabs
        function showTab(tab) {
            // Remover active de todos los botones
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Agregar active al botón clickeado
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Si no hay event, activar el botón correspondiente
                const targetBtn = document.querySelector(`.tab-btn[onclick*="${tab}"]`);
                if (targetBtn) targetBtn.classList.add('active');
            }
            
            // Mostrar/ocultar vistas
            const mainGridContainer = document.querySelector('.calendar-container');
            const yearView = document.getElementById('yearView');
            const monthNav = document.querySelector('.month-nav');
            
            if (tab === 'year') {
                if (monthNav) monthNav.style.display = 'none';
                mainGridContainer.style.display = 'none';
                yearView.style.display = 'block';
                updateYearNav();
                renderYear();
                // Precarga en segundo plano para que aparezcan todos los turnos del año
                const yr = yearViewYear ?? currentDate.getFullYear();
                preloadYearEvents(yr);
            } else if (tab === 'calendar') {
                if (monthNav) monthNav.style.display = 'flex';
                yearView.style.display = 'none';
                mainGridContainer.style.display = 'block';
            } else if (tab === 'summary') {
                window.location.href = 'summary.html';
            }
        }

        // Activar modo pintar
        function activatePaintMode() {
            console.log('🎨 Activando modo pintar...');
            // Mostrar el pop-up de selección de turnos
            openShiftsPopup();
        }

        // Abrir pop-up de turnos
        async function openShiftsPopup() {
            console.log('📂 Abriendo pop-up de turnos...');
            const popup = document.getElementById('shiftsPopup');
            
            if (!popup) {
                console.error('❌ No se encontró el elemento shiftsPopup');
                return;
            }
            
            console.log('✅ Pop-up encontrado, agregando clase show...');
            
            // Mostrar pop-up: remover atributo hidden y agregar clase show
            popup.removeAttribute('hidden');
            popup.classList.add('show');
            await renderShiftsForPainting();
            console.log('✅ Pop-up abierto');
        }

        // Cerrar pop-up de turnos
        function closeShiftsPopup() {
            const popup = document.getElementById('shiftsPopup');
            
            // Ocultar pop-up: agregar atributo hidden y remover clase show
            popup.setAttribute('hidden', '');
            popup.classList.remove('show');
            
            // Salir del modo pintura si estaba activo
            exitPaintMode();
        }

        // Renderizar turnos en el pop-up
        async function renderShiftsForPainting() {
            console.log('🎨 Renderizando turnos para pintar...');
            const container = document.getElementById('shiftsScroll');
            if (!container) {
                console.error('❌ No se encontró el contenedor shiftsScroll');
                return;
            }
            container.innerHTML = '';

            console.log('📊 Turnos disponibles:', shiftTemplates.length);

            // Si no hay turnos, intentar cargarlos
            if (shiftTemplates.length === 0) {
                console.log('⚠️ No hay turnos, intentando cargarlos...');
                if (isFirebaseConnected) {
                    await loadShiftTemplates();
                }
                
                // Si aún no hay turnos, mostrar mensaje
                if (shiftTemplates.length === 0) {
                    console.log('❌ Aún no hay turnos disponibles');
                    container.innerHTML = '<div style="padding: 16px; color: #999; text-align: center; width: 100%;">No hay turnos disponibles<br/>Crea turnos en la sección "TURNOS"</div>';
                    return;
                }
            }

            console.log('✅ Renderizando', shiftTemplates.length, 'turnos...');
            // Renderizar cada turno
            shiftTemplates.forEach(shift => {
                const button = document.createElement('button');
                button.className = 'shift-button-paint';
                
                // Determinar el color de fondo
                const backgroundColor = shift.backgroundColor || shift.colorHex || shift.color || '#9E9E9E';
                button.style.backgroundColor = backgroundColor;
                
                // Usar la abreviatura si existe, sino el nombre
                const displayText = shift.abbreviation || shift.name || 'Turno';
                button.textContent = displayText;
                
                // Evento click para pintar con este turno
                button.onclick = () => selectShiftForPainting(shift);
                
                container.appendChild(button);
            });

            // Añadir botón de borrar
            const deleteButton = document.createElement('button');
            deleteButton.className = 'shift-button-delete';
            deleteButton.innerHTML = '🗑️';
            deleteButton.title = 'Borrar turnos del día seleccionado';
            deleteButton.onclick = () => selectDeleteMode();
            container.appendChild(deleteButton);
            
            console.log('✅ Turnos renderizados correctamente');
        }

        // Variable para almacenar el turno seleccionado para pintar
        let selectedShiftForPainting = null;
        let isDeleteMode = false;

        // Seleccionar turno para pintar
        function selectShiftForPainting(shift) {
            selectedShiftForPainting = shift;
            // NO cerrar el pop-up - se mantiene abierto
            
            // Cambiar el cursor a "modo pintura"
            document.body.style.cursor = 'crosshair';
            
            // Agregar event listeners a las celdas del calendario
            const dayCells = document.querySelectorAll('.calendar-day');
            dayCells.forEach(cell => {
                // Crear nuevo onclick que pinta
                const paintOnclick = (e) => {
                    // Prevenir que se abra el modal de detalles del día
                    e.stopPropagation();
                    // Pintar el día con el turno seleccionado
                    paintDay(cell, shift);
                    // NO salir del modo pintura - permitir seguir pintando
                };
                
                cell.onclick = paintOnclick;
                cell.style.cursor = 'pointer';
            });

            // No mostrar alert - el pop-up permanece visible
            console.log(`🎨 Modo PINTAR activo - Turno: ${shift.name || shift.abbreviation}`);
        }

        // Salir del modo pintura
        function exitPaintMode() {
            document.body.style.cursor = '';
            selectedShiftForPainting = null;
            isDeleteMode = false;
            
            // Restaurar el cursor de las celdas (no re-renderizar para evitar flashes)
            const dayCells = document.querySelectorAll('.calendar-day');
            dayCells.forEach(cell => {
                cell.style.cursor = '';
                // Restaurar handler por defecto: abrir modal del día
                const dateStr = cell.dataset.date;
                if (dateStr) {
                    const dateObj = new Date(dateStr);
                    cell.onclick = (e) => {
                        e.stopPropagation();
                        openDayModal(dateObj);
                    };
                } else {
                    cell.onclick = null;
                }
            });
            
            console.log('✅ Modo pintura desactivado');
        }

        // Seleccionar modo borrar
        function selectDeleteMode() {
            isDeleteMode = true;
            selectedShiftForPainting = null;
            
            // Cambiar el cursor a "modo borrar"
            document.body.style.cursor = 'not-allowed';
            
            // Agregar event listeners a las celdas del calendario
            const dayCells = document.querySelectorAll('.calendar-day');
            dayCells.forEach(cell => {
                const deleteOnclick = (e) => {
                    e.stopPropagation();
                    deleteDayShifts(cell);
                };
                
                cell.onclick = deleteOnclick;
                cell.style.cursor = 'not-allowed';
            });

            console.log('🗑️ Modo BORRAR activo');
        }

        // Borrar turnos de un día
        async function deleteDayShifts(cell) {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;

            const date = new Date(dateStr);
            const dateKey = formatDateKey(date);
            
            console.log('🗑️ Borrando turnos del día:', dateKey);

            try {
                if (isFirebaseConnected) {
                    // Eliminar el documento completo del día
                    await db.collection('calendar_events').doc(dateKey).delete();
                    console.log('✅ Turnos eliminados de Firebase');
                } else {
                    // Eliminar localmente
                    await saveEventsToLocalStorage(date, []);
                }

                // Actualizar solo la visualización de este día
                updateDayDisplay(cell, []);
                
            } catch (error) {
                console.error('❌ Error borrando turnos:', error);
            }
        }

        // Pintar un día con un turno
        async function paintDay(cell, shift) {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;
            if (!shift) {
                console.warn('⚠️ paintDay llamado sin shift válido');
                return;
            }

            const date = new Date(dateStr);
            const dateKey = formatDateKey(date);
            
            console.log('🎨 Pintando día:', dateKey, 'con turno:', shift);

            try {
                // Obtener eventos existentes del día
                const existingEvents = await getEventsForDate(date);
                
                // Verificar si ya existe este turno
                const shiftText = (shift && (shift.abbreviation || shift.name)) || 'Turno';
                const exists = existingEvents.some(evt => (evt.shiftId && evt.shiftId === shift.id) || evt.text === shiftText);
                
                if (exists) {
                    console.log('⚠️ Ya existe un evento para este día con este turno');
                    return; // No mostrar alert para no interrumpir el flujo
                }

                // Crear nuevo evento
                const newEvent = {
                    text: shiftText,
                    shiftId: shift.id,
                    userId: currentUserId,
                    userColor: shift.backgroundColor || shift.colorHex || shift.color,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };

                // Agregar el nuevo evento a la lista
                existingEvents.push(newEvent);

                if (isFirebaseConnected) {
                    // Guardar en Firebase
                    await db.collection('calendar_events').doc(dateKey).set({
                        events: existingEvents
                    }, { merge: true });
                    console.log('✅ Turno guardado en Firebase');
                } else {
                    // Guardar localmente
                    await saveEventsToLocalStorage(date, existingEvents);
                }

                // Actualizar solo la visualización de este día sin re-renderizar todo
                updateDayDisplay(cell, existingEvents);
                
            } catch (error) {
                console.error('❌ Error pintando día:', error);
            }
        }

        // Actualizar visualización de un día sin re-renderizar todo el calendario
        async function updateDayDisplay(cell, events) {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;

            const date = new Date(dateStr);
            const dateKey = formatDateKey(date);
            
            // Actualizar la caché con los nuevos eventos
            if (!eventsCache.events) eventsCache.events = {};
            eventsCache.events[dateKey] = events;
            
            // Filtrar solo turnos (excluir notas)
            const shifts = events
                .filter(event => event.type !== 'note')
                .map(e => normalizeShiftEvent(e));
            
            // Obtener el número del día
            const dayNumber = cell.querySelector('.day-number');
            if (!dayNumber) return;
            
            // Limpiar estilo anterior de la celda
            cell.style.background = '';
            cell.style.backgroundColor = '';
            cell.style.backgroundImage = '';
            
            // Limpiar eventos visuales previos
            const eventsEl = cell.querySelector('.day-events');
            if (eventsEl) {
                eventsEl.remove();
            }
            
            // Limpiar textos de turnos previos
            const shiftTexts = cell.querySelectorAll('.shift-text-full, .shift-text-half, .event-badge');
            shiftTexts.forEach(el => el.remove());
            
            // Limpiar iconos de categoría previos
            const categoryIconsEl = cell.querySelector('.category-icons');
            if (categoryIconsEl) {
                categoryIconsEl.remove();
            }
            
            // Limpiar texto de nota previo
            const noteTextEl = cell.querySelector('.note-text');
            if (noteTextEl) {
                noteTextEl.remove();
            }
            
            // SIEMPRE mostrar el número del día, pero con estilo para que sea visible
            dayNumber.style.display = 'block';
            dayNumber.style.position = 'absolute';
            dayNumber.style.top = '2px';
            dayNumber.style.right = '2px';
            dayNumber.style.zIndex = '100';
            dayNumber.style.fontWeight = '600';
            dayNumber.style.fontSize = '11px';
            
            if (shifts.length > 0) {
                if (cell.classList.contains('other-month')) {
                    cell.classList.remove('other-month');
                    cell.style.opacity = '1';
                }
                
                if (shifts.length === 1) {
                    // Un solo turno: pintar toda la celda
                    const template = getTemplateForEvent(shifts[0]);
                    const color = template ? (template.backgroundColor || template.colorHex || template.color) : 
                                  (shifts[0].backgroundColor || shifts[0].colorHex || shifts[0].color || shifts[0].userColor || getUserColor(shifts[0].userId));
                    
                    cell.style.backgroundColor = color;
                    
                    // Número del día en esquina superior derecha, sin fondo
                    dayNumber.style.backgroundColor = '';
                    dayNumber.style.padding = '';
                    dayNumber.style.borderRadius = '';
                    dayNumber.style.color = '#ffffff';
                    dayNumber.style.textShadow = '0 0 3px rgba(0,0,0,0.7)';
                    
                    // Crear texto del turno centrado
                    const shiftText = document.createElement('div');
                    shiftText.className = 'shift-text-full';
                    shiftText.textContent = template ? (template.abbreviation || template.name) : shifts[0].text;
                    const fontSize = getShiftFontSize(template, 13);
                    shiftText.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    cell.appendChild(shiftText);
                    
                } else if (shifts.length === 2) {
                    // Dos turnos: dividir la celda en dos
                    const shift1 = shifts[0];
                    const shift2 = shifts[1];
                    
                    const template1 = getTemplateForEvent(shift1);
                    const template2 = getTemplateForEvent(shift2);
                    
                    const color1 = template1 ? (template1.backgroundColor || template1.colorHex || template1.color) : 
                                   (shift1.backgroundColor || shift1.colorHex || shift1.color || shift1.userColor || getUserColor(shift1.userId));
                    const color2 = template2 ? (template2.backgroundColor || template2.colorHex || template2.color) : 
                                   (shift2.backgroundColor || shift2.colorHex || shift2.color || shift2.userColor || getUserColor(shift2.userId));
                    
                    // Usar gradiente lineal para dividir en dos
                    cell.style.background = `linear-gradient(to bottom, ${color1} 50%, ${color2} 50%)`;
                    
                    // Número del día sin fondo, con sombra para contraste
                    dayNumber.style.backgroundColor = '';
                    dayNumber.style.padding = '';
                    dayNumber.style.borderRadius = '';
                    dayNumber.style.color = '#ffffff';
                    dayNumber.style.textShadow = '0 0 3px rgba(0,0,0,0.7)';

                    // Crear texto para cada mitad
                    const text1 = document.createElement('div');
                    text1.className = 'shift-text-half';
                    text1.textContent = template1 ? (template1.abbreviation || template1.name) : shift1.text;
                    const fontSize1 = getShiftFontSize(template1, 12);
                    text1.style.cssText = `
                        position: absolute;
                        top: 25%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize1}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    cell.appendChild(text1);

                    const text2 = document.createElement('div');
                    text2.className = 'shift-text-half';
                    text2.textContent = template2 ? (template2.abbreviation || template2.name) : shift2.text;
                    const fontSize2 = getShiftFontSize(template2, 12);
                    text2.style.cssText = `
                        position: absolute;
                        top: 75%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize2}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    cell.appendChild(text2);

                } else if (shifts.length === 3) {
                    // Tres turnos: dividir en tres bandas
                    const [s1, s2, s3] = shifts;
                    const t1 = shiftTemplates.find(t => t.name === s1.text || t.abbreviation === s1.text);
                    const t2 = shiftTemplates.find(t => t.name === s2.text || t.abbreviation === s2.text);
                    const t3 = shiftTemplates.find(t => t.name === s3.text || t.abbreviation === s3.text);
                    const c1 = t1 ? (t1.backgroundColor || t1.colorHex || t1.color) : (s1.userColor || getUserColor(s1.userId));
                    const c2 = t2 ? (t2.backgroundColor || t2.colorHex || t2.color) : (s2.userColor || getUserColor(s2.userId));
                    const c3 = t3 ? (t3.backgroundColor || t3.colorHex || t3.color) : (s3.userColor || getUserColor(s3.userId));
                    cell.style.background = `linear-gradient(to bottom, ${c1} 33.333%, ${c2} 33.333% 66.666%, ${c3} 66.666%)`;

                    dayNumber.style.backgroundColor = '';
                    dayNumber.style.color = '#ffffff';
                    dayNumber.style.textShadow = '0 0 3px rgba(0,0,0,0.7)';

                    const mk = (txt, top, tmpl) => {
                        const el = document.createElement('div');
                        el.className = 'shift-text-third';
                        el.textContent = txt;
                        const fontSize = getShiftFontSize(tmpl, 11);
                        el.style.cssText = `position:absolute; top:${top}%; left:50%; transform:translate(-50%,-50%); color:white; font-weight:700; font-size:${fontSize}px; white-space:nowrap; z-index:10;`;
                        cell.appendChild(el);
                    };
                    mk(t1 ? (t1.abbreviation || t1.name) : s1.text, 16.5, t1);
                    mk(t2 ? (t2.abbreviation || t2.name) : s2.text, 50, t2);
                    mk(t3 ? (t3.abbreviation || t3.name) : s3.text, 83.5, t3);
                    
                } else {
                    // Más de dos turnos: mostrar los primeros tres
                    shifts.slice(0, 3).forEach((event, index) => {
                        const template = getTemplateForEvent(event);
                        const color = template ? (template.backgroundColor || template.colorHex || template.color) : 
                                      (event.backgroundColor || event.colorHex || event.color || event.userColor || getUserColor(event.userId));
                        
                        const eventEl = document.createElement('div');
                        eventEl.className = 'event-badge';
                        const fontSize = getShiftFontSize(template, 10);
                        eventEl.style.cssText = `
                            position: absolute;
                            top: ${20 + index * 30}%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background-color: ${color};
                            color: white;
                            padding: 2px 6px;
                            border-radius: 4px;
                            font-size: ${fontSize}px;
                            font-weight: 600;
                            z-index: 10;
                        `;
                        eventEl.textContent = template ? (template.abbreviation || template.name) : event.text;
                        cell.appendChild(eventEl);
                    });
                }
            } else {
                // No hay turnos: mostrar el número del día con estilo normal
                dayNumber.style.backgroundColor = '';
                dayNumber.style.padding = '';
                dayNumber.style.borderRadius = '';
                dayNumber.style.color = '';
            }
            
            // Agregar iconos de categoría con el color del usuario
            const note = events.find(event => event.type === 'note');
            if (note) {
                // Obtener el color del usuario que creó la nota
                const userColor = note.userColor || getUserColor(note.userId);
                console.log('🎨 Color de nota:', userColor, 'userId:', note.userId, 'userId type:', typeof note.userId, 'users:', users.map(u => ({id: u.id, idType: typeof u.id, name: u.name, color: u.color})));
                
                // Si hay nota con texto, ocultar los textos de los turnos para evitar superposición
                if (note.text && note.text.trim() !== '') {
                    const shiftTexts = cell.querySelectorAll('.shift-text-full, .shift-text-half, .shift-text-third, .event-badge');
                    shiftTexts.forEach(el => el.style.display = 'none');
                }
                
                // Agregar texto de la nota si existe
                if (note.text && note.text.trim() !== '') {
                    const noteTextEl = document.createElement('div');
                    noteTextEl.className = 'note-text';
                    noteTextEl.textContent = note.text;
                    // Usar el tamaño guardado en la nota o el por defecto
                    const noteFontSize = note.textSize || 11;
                    noteTextEl.style.cssText = `
                        position: absolute;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: ${userColor};
                        font-weight: 700;
                        font-size: ${noteFontSize}px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                        max-width: calc(100% - 8px);
                        z-index: 15;
                    `;
                    cell.appendChild(noteTextEl);
                }
                
                // Agregar iconos de categoría si existen
                if (note.categories && note.categories.length > 0) {
                    const categoriesEl = document.createElement('div');
                    categoriesEl.className = 'category-icons';
                    
                    note.categories.forEach(category => {
                        if (category.icon && category.icon.trim() !== '') {
                            const iconEl = document.createElement('span');
                            iconEl.className = 'category-icon';
                            iconEl.textContent = category.icon;
                            iconEl.title = category.text;
                            // Aplicar el color del usuario al icono
                            iconEl.style.color = userColor;
                            iconEl.style.borderColor = userColor;
                            categoriesEl.appendChild(iconEl);
                        }
                    });
                    
                    if (categoriesEl.children.length > 0) {
                        cell.appendChild(categoriesEl);
                    }
                }
            }
        }

        // Activar modo editar
        function activateEditMode() {
            window.location.href = 'users-management.html';
        }


        // Actualizar info del usuario actual (oculto)
        function updateCurrentUserInfo() {
            const user = users.find(u => u.id === currentUserId);
            // Info del usuario oculta para maximizar espacio del calendario
            // document.getElementById('currentUserInfo').textContent = 
            //     `Usuario actual: ${user.name}`;
        }

        // Renderizar calendario con debounce
        function scheduleRenderCalendar() {
            // Cancelar render anterior si existe
            if (renderTimeout) {
                clearTimeout(renderTimeout);
            }
            
            // Programar nuevo render con delay
            renderTimeout = setTimeout(() => {
                renderCalendar();
            }, 200);
        }

        // Renderizar calendario
        async function renderCalendar(force = false) {
            // Prevenir renders muy frecuentes (mínimo 100ms entre renders)
            const now = Date.now();
            if (!force && now - lastRenderTime < 100) {
                console.log('⏳ Render muy frecuente, saltando...');
                return;
            }
            
            if (isRendering) {
                console.log('⏳ Ya se está renderizando, saltando...');
                return;
            }
            
            isRendering = true;
            lastRenderTime = now;
            const container = document.getElementById('calendarGrid');
            
            // Limpiar completamente el contenedor
            container.innerHTML = '';

            // Título del mes
            document.getElementById('monthTitle').textContent = 
                `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`;

            // Headers de días de la semana
            weekDays().forEach(day => {
                const header = document.createElement('div');
                header.className = 'weekday-header';
                header.textContent = day;
                container.appendChild(header);
            });

            // Calcular días del mes
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startDayOfWeek = firstDay.getDay();

            // Ajustar para que la semana empiece en lunes
            const adjustedStartDay = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;
            
            // Cargar todos los eventos del mes de una vez (optimización)
            if (isFirebaseConnected && eventsCache.month !== `${year}-${month}`) {
                await loadAllEventsForMonth(year, month);
            }
            
            // Días del mes anterior (solo los necesarios para completar la primera semana)
            if (adjustedStartDay > 0) {
                const prevMonthLastDay = new Date(year, month, 0).getDate();
                for (let i = adjustedStartDay - 1; i >= 0; i--) {
                    const day = prevMonthLastDay - i;
                    const date = new Date(year, month - 1, day);
                    renderDay(container, date, true);
                }
            }

            // Días del mes actual
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                renderDay(container, date, false);
            }

            // Días del mes siguiente (completar sólo si necesitamos 6 semanas)
            const totalCellsUsed = adjustedStartDay + daysInMonth;
            const needsSixWeeks = totalCellsUsed > 35; // 5 semanas * 7 = 35

            // Marcar el grid para ajustar alturas cuando son 5 semanas
            const gridEl = document.getElementById('calendarGrid');
            if (needsSixWeeks) {
                gridEl.classList.remove('five-weeks');
            } else {
                gridEl.classList.add('five-weeks');
            }

            if (needsSixWeeks) {
                const remainingCells = 42 - totalCellsUsed; // completar a 6 semanas
                if (remainingCells > 0) {
                    for (let day = 1; day <= remainingCells; day++) {
                        const date = new Date(year, month + 1, day);
                        renderDay(container, date, true);
                    }
                }
            } else {
                // Completar la última semana hasta 5 semanas (35 celdas)
                const remainingToFiveWeeks = 35 - totalCellsUsed;
                if (remainingToFiveWeeks > 0) {
                    for (let day = 1; day <= remainingToFiveWeeks; day++) {
                        const date = new Date(year, month + 1, day);
                        renderDay(container, date, true);
                    }
                }
            }
            
            isRendering = false;
            
            // Si estamos en modo pintura o borrar, restaurar los event listeners
            const dayCells = document.querySelectorAll('.calendar-day');
            
            if (selectedShiftForPainting) {
                // Modo pintura
                dayCells.forEach(cell => {
                    const paintOnclick = (e) => {
                        e.stopPropagation();
                        // Capturar referencia actual de turno; si fuese null, salir sin error
                        const shiftRef = selectedShiftForPainting;
                        if (!shiftRef) return exitPaintMode();
                        paintDay(cell, shiftRef);
                    };
                    cell.onclick = paintOnclick;
                    cell.style.cursor = 'pointer';
                });
                document.body.style.cursor = 'crosshair';
            } else if (isDeleteMode) {
                // Modo borrar
                dayCells.forEach(cell => {
                    const deleteOnclick = (e) => {
                        e.stopPropagation();
                        deleteDayShifts(cell);
                    };
                    cell.onclick = deleteOnclick;
                    cell.style.cursor = 'not-allowed';
                });
                document.body.style.cursor = 'not-allowed';
            }
        }

        // Cargar todos los eventos del mes de una vez
        async function loadAllEventsForMonth(year, month) {
            eventsCache.month = `${year}-${month}`;
            eventsCache.events = {};
            
            if (!isFirebaseConnected) return;
            
            try {
                // Calcular rango de fechas del mes
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const daysInMonth = lastDay.getDate();
                
                // Cargar eventos de todos los días del mes en paralelo
                const promises = [];
                for (let day = 1; day <= daysInMonth; day++) {
                    const date = new Date(year, month, day);
                    const dateKey = formatDateKey(date);
                    promises.push(
                        db.collection('calendar_events').doc(dateKey).get().then(doc => {
                            if (doc.exists) {
                                eventsCache.events[dateKey] = doc.data().events || [];
                            }
                        })
                    );
                }
                
                await Promise.all(promises);
                console.log('✅ Eventos del mes cargados en caché');
            } catch (error) {
                console.error('❌ Error cargando eventos del mes:', error);
            }
        }

        // Añadir eventos de un mes al caché SIN resetear el resto
        async function loadEventsForMonthIntoCache(year, month) {
            if (!isFirebaseConnected) return;
            if (!eventsCache.events) eventsCache.events = {};
            try {
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const daysInMonth = lastDay.getDate();
                const ops = [];
                for (let day = 1; day <= daysInMonth; day++) {
                    const date = new Date(year, month, day);
                    const dateKey = formatDateKey(date);
                    ops.push(
                        db.collection('calendar_events').doc(dateKey).get().then(doc => {
                            eventsCache.events[dateKey] = doc.exists ? (doc.data().events || []) : [];
                        })
                    );
                }
                await Promise.all(ops);
            } catch (e) {
                console.error('❌ Error cargando mes en caché:', e);
            }
        }

        // Precargar todo el año actual (12 meses) en segundo plano y luego refrescar vista anual
        async function preloadYearEvents(year) {
            if (!isFirebaseConnected) return;
            if (!eventsCache.events) eventsCache.events = {};
            try {
                const tasks = [];
                for (let m = 0; m < 12; m++) tasks.push(loadEventsForMonthIntoCache(year, m));
                await Promise.all(tasks);
                // Si sigue visible la vista anual, re-renderizar
                const yearView = document.getElementById('yearView');
                if (yearView && yearView.style.display !== 'none') {
                    renderYear();
                }
            } catch (e) {
                console.error('❌ Error precargando eventos del año:', e);
            }
        }

        // Renderizar un día
        function renderDay(container, date, isOtherMonth) {
            const dayEl = document.createElement('div');
            dayEl.className = 'calendar-day';
            dayEl.dataset.date = date.toISOString(); // Guardar la fecha en dataset para acceso desde fuera
            
            if (isOtherMonth) {
                dayEl.classList.add('other-month');
            }

            // Marcar día actual
            const today = new Date();
            if (date.toDateString() === today.toDateString()) {
                dayEl.classList.add('today');
            }

            // Número del día
            const numberEl = document.createElement('div');
            numberEl.className = 'day-number';
            numberEl.textContent = date.getDate();
            // Estilo base del número del día
            numberEl.style.position = 'absolute';
            numberEl.style.top = '2px';
            numberEl.style.right = '2px';
            numberEl.style.zIndex = '100';
            numberEl.style.fontWeight = '600';
            numberEl.style.fontSize = '11px';
            dayEl.appendChild(numberEl);

            // Eventos del día (cargar pero aplicar el nuevo estilo después)
            const eventsEl = document.createElement('div');
            eventsEl.className = 'day-events';
            
            const events = getEventsForDateCached(date);
            dayEl.appendChild(eventsEl);
            
            // Aplicar el nuevo estilo de visualización
            const shifts = events
                .filter(event => event.type !== 'note')
                .map(e => normalizeShiftEvent(e));
            if (shifts.length > 0) {
                // Si tiene turnos, asegurar que no esté atenuado como "otro mes"
                if (dayEl.classList.contains('other-month')) {
                    dayEl.classList.remove('other-month');
                    dayEl.style.opacity = '1';
                }
                
                if (shifts.length === 1) {
                    // Un solo turno: pintar toda la celda
                    const template = getTemplateForEvent(shifts[0]);
                    const color = template ? (template.backgroundColor || template.colorHex || template.color) : 
                                  (shifts[0].backgroundColor || shifts[0].colorHex || shifts[0].color || shifts[0].userColor || getUserColor(shifts[0].userId));
                    
                    dayEl.style.backgroundColor = color;
                    
                    // Ajustar número: sin fondo, alto contraste con el fondo del turno
                    numberEl.style.backgroundColor = 'transparent';
                    numberEl.style.padding = '0';
                    numberEl.style.borderRadius = '0';
                    numberEl.style.color = getContrastColor(color);
                    numberEl.style.textShadow = '0 1px 2px rgba(0,0,0,0.35)';
                    
                    const shiftText = document.createElement('div');
                    shiftText.className = 'shift-text-full';
                    shiftText.textContent = template ? (template.abbreviation || template.name) : shifts[0].text;
                    const fontSize = getShiftFontSize(template, 13);
                    shiftText.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    dayEl.appendChild(shiftText);
                    
                } else if (shifts.length === 2) {
                    // Dos turnos: dividir la celda en dos
                    const shift1 = shifts[0];
                    const shift2 = shifts[1];
                    
                    const template1 = getTemplateForEvent(shift1);
                    const template2 = getTemplateForEvent(shift2);
                    
                    const color1 = template1 ? (template1.backgroundColor || template1.colorHex || template1.color) : 
                                   (shift1.backgroundColor || shift1.colorHex || shift1.color || shift1.userColor || getUserColor(shift1.userId));
                    const color2 = template2 ? (template2.backgroundColor || template2.colorHex || template2.color) : 
                                   (shift2.backgroundColor || shift2.colorHex || shift2.color || shift2.userColor || getUserColor(shift2.userId));
                    
                    dayEl.style.background = `linear-gradient(to bottom, ${color1} 50%, ${color2} 50%)`;
                    
                    // En gradiente: usar blanco con sombra para legibilidad
                    numberEl.style.backgroundColor = 'transparent';
                    numberEl.style.padding = '0';
                    numberEl.style.borderRadius = '0';
                    numberEl.style.color = '#ffffff';
                    numberEl.style.textShadow = '0 1px 3px rgba(0,0,0,0.6)';
                    
                    const text1 = document.createElement('div');
                    text1.className = 'shift-text-half';
                    text1.textContent = template1 ? (template1.abbreviation || template1.name) : shift1.text;
                    const fontSize1 = getShiftFontSize(template1, 12);
                    text1.style.cssText = `
                        position: absolute;
                        top: 25%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize1}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    dayEl.appendChild(text1);

                    const text2 = document.createElement('div');
                    text2.className = 'shift-text-half';
                    text2.textContent = template2 ? (template2.abbreviation || template2.name) : shift2.text;
                    const fontSize2 = getShiftFontSize(template2, 12);
                    text2.style.cssText = `
                        position: absolute;
                        top: 75%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize2}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    dayEl.appendChild(text2);
                    
                } else {
                    // Más de dos turnos: mostrar los primeros tres
                    shifts.slice(0, 3).forEach((event, index) => {
                        const template = getTemplateForEvent(event);
                        const color = template ? (template.backgroundColor || template.colorHex || template.color) : 
                                      (event.userColor || getUserColor(event.userId));
                        
                        const eventEl = document.createElement('div');
                        eventEl.className = 'event-badge';
                        const fontSize = getShiftFontSize(template, 10);
                        eventEl.style.cssText = `
                            position: absolute;
                            top: ${20 + index * 30}%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background-color: ${color};
                            color: ${getContrastColorInline(color)};
                            padding: 2px 6px;
                            border-radius: 4px;
                            font-size: ${fontSize}px;
                            font-weight: 600;
                            z-index: 10;
                        `;
                        eventEl.textContent = template ? (template.abbreviation || template.name) : event.text;
                        dayEl.appendChild(eventEl);
                    });
                }
            }

            // Asegurar que el día de hoy se vea con círculo, sin importar el fondo de turnos
            const todayCheck = new Date();
            if (date.toDateString() === todayCheck.toDateString()) {
                numberEl.style.backgroundColor = '#FF1744';
                numberEl.style.color = '#FFFFFF';
                numberEl.style.borderRadius = '50%';
                numberEl.style.padding = '2px 6px';
                numberEl.style.textShadow = 'none';
            }

            // Agregar texto de nota e iconos de categorías
            const note = events.find(event => event.type === 'note');
            if (note) {
                // Obtener el color del usuario que creó la nota
                const userColor = note.userColor || getUserColor(note.userId);
                console.log('🎨 Color de nota (renderDay):', userColor, 'userId:', note.userId, 'userId type:', typeof note.userId, 'users:', users.map(u => ({id: u.id, idType: typeof u.id, name: u.name, color: u.color})));
                
                // Si hay nota con texto, ocultar los textos de los turnos para evitar superposición
                if (note.text && note.text.trim() !== '') {
                    const shiftTexts = dayEl.querySelectorAll('.shift-text-full, .shift-text-half, .shift-text-third, .event-badge');
                    shiftTexts.forEach(el => el.style.display = 'none');
                }
                
                // Agregar texto de la nota si existe
                if (note.text && note.text.trim() !== '') {
                    const noteTextEl = document.createElement('div');
                    noteTextEl.className = 'note-text';
                    noteTextEl.textContent = note.text;
                    // Usar el tamaño guardado en la nota o el por defecto
                    const noteFontSize = note.textSize || 11;
                    noteTextEl.style.cssText = `
                        position: absolute;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        color: ${resolveNoteColor(userColor, shifts)};
                        font-weight: 700;
                        font-size: ${noteFontSize}px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                        max-width: calc(100% - 8px);
                        z-index: 15;
                        text-shadow: 0 1px 2px rgba(0,0,0,0.25);
                    `;
                    dayEl.appendChild(noteTextEl);
                }
                
                // Agregar iconos de categoría si existen
                if (note.categories && note.categories.length > 0) {
                    const categoriesEl = document.createElement('div');
                    categoriesEl.className = 'category-icons';
                    
                    note.categories.forEach(category => {
                        if (category.icon && category.icon.trim() !== '') {
                            const iconEl = document.createElement('span');
                            iconEl.className = 'category-icon';
                            iconEl.textContent = category.icon;
                            iconEl.title = category.text;
                            // Aplicar el color del usuario al icono
                            iconEl.style.color = userColor;
                            iconEl.style.borderColor = userColor;
                            categoriesEl.appendChild(iconEl);
                        }
                    });
                    
                    if (categoriesEl.children.length > 0) {
                        dayEl.appendChild(categoriesEl);
                    }
                }
            }

            // Click para abrir modal (solo si no estamos en modo pintura o borrar)
            dayEl.addEventListener('click', (e) => {
                if (!selectedShiftForPainting && !isDeleteMode) {
                    openDayModal(date);
                }
            });

            container.appendChild(dayEl);
        }

        // Obtener eventos para una fecha
        async function getEventsForDate(date) {
            const dateKey = formatDateKey(date);
            
            // Primero intentar desde la caché
            if (eventsCache.events && eventsCache.events[dateKey]) {
                return eventsCache.events[dateKey];
            }
            
            if (isFirebaseConnected) {
                try {
                    const docRef = db.collection('calendar_events').doc(dateKey);
                    const doc = await docRef.get();
                    
                    if (doc.exists) {
                        const events = doc.data().events || [];
                        // Guardar en caché para próximas consultas
                        if (!eventsCache.events) eventsCache.events = {};
                        eventsCache.events[dateKey] = events;
                        return events;
                    }
                    return [];
                } catch (error) {
                    console.error('❌ Error obteniendo eventos de Firestore:', error);
                    // Fallback a localStorage
                    return getEventsFromLocalStorage(date);
                }
            } else {
                return getEventsFromLocalStorage(date);
            }
        }

        // Fallback: obtener eventos de localStorage
        function getEventsFromLocalStorage(date) {
            const dateKey = formatDateKey(date);
            const eventsJson = localStorage.getItem('calendar_events');
            const allEvents = eventsJson ? JSON.parse(eventsJson) : {};
            return allEvents[dateKey] || [];
        }

        // Obtener eventos sincrónicamente desde caché precargada o localStorage (sin esperas)
        function getEventsForDateCached(date) {
            const dateKey = formatDateKey(date);
            if (eventsCache.events && eventsCache.events[dateKey]) {
                return eventsCache.events[dateKey];
            }
            return getEventsFromLocalStorage(date);
        }

        // Guardar eventos
        async function saveEvents(date, events) {
            const dateKey = formatDateKey(date);
            
            if (isFirebaseConnected) {
                try {
                    await db.collection('calendar_events').doc(dateKey).set({
                        events: events,
                        lastModified: firebase.firestore.FieldValue.serverTimestamp(),
                        modifiedBy: currentUserId
                    });
                    console.log('✅ Eventos guardados en Firestore');
                } catch (error) {
                    console.error('❌ Error guardando en Firestore:', error);
                    // Fallback a localStorage
                    saveEventsToLocalStorage(date, events);
                }
            } else {
                saveEventsToLocalStorage(date, events);
            }
        }

        // Fallback: guardar eventos en localStorage
        function saveEventsToLocalStorage(date, events) {
            const dateKey = formatDateKey(date);
            const eventsJson = localStorage.getItem('calendar_events');
            const allEvents = eventsJson ? JSON.parse(eventsJson) : {};
            allEvents[dateKey] = events;
            localStorage.setItem('calendar_events', JSON.stringify(allEvents));
            console.log('💾 Eventos guardados en localStorage');
        }

        // Formatear fecha como clave
        function formatDateKey(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Formatear fecha para mostrar
        function formatDateDisplay(date) {
            const day = date.getDate();
            const month = monthNames[date.getMonth()];
            const year = date.getFullYear();
            return `${day} de ${month} de ${year}`;
        }

        // Obtener color de usuario
        function getUserColor(userId) {
            const user = users.find(u => u.id === userId);
            return user ? user.color : '#999';
        }

        // Obtener nombre de usuario
        function getUserName(userId) {
            const user = users.find(u => u.id === userId);
            return user ? user.name : 'Usuario';
        }

        // Obtener plantilla de turno a partir de un evento (prioriza shiftId, luego nombre/abreviatura)
        function getTemplateForEvent(event) {
            if (!event) return null;
            if (event.shiftId) {
                const byId = shiftTemplates.find(t => t.id === event.shiftId);
                if (byId) return byId;
            }
            const text = (event.text || '').toString().trim().toLowerCase();
            if (!text) return null;
            return shiftTemplates.find(t => {
                const n = (t.name||'').toString().trim().toLowerCase();
                const a = (t.abbreviation||'').toString().trim().toLowerCase();
                return n === text || a === text;
            }) || null;
        }

        // Obtener el tamaño de fuente del template del turno, con valor por defecto
        function getShiftFontSize(template, defaultSize = 13) {
            if (!template) return defaultSize;
            return template.textSize || defaultSize;
        }

        // Normaliza un evento de turno a referencia canónica: asegura shiftId y texto estándar
        function normalizeShiftEvent(event) {
            if (!event) return event;
            const tmpl = getTemplateForEvent(event);
            if (tmpl) {
                // Asegurar id y texto consistente
                event.shiftId = tmpl.id;
                event.text = tmpl.abbreviation || tmpl.name || event.text;
                // Asegurar color para fallback
                event.userColor = event.userColor || tmpl.backgroundColor || tmpl.colorHex || tmpl.color;
            }
            return event;
        }

        // Utilidades de color
        function normalizeHex(color) {
            if (!color) return null;
            let c = color.trim();
            if (c.startsWith('rgb')) {
                // rgb/rgba -> hex aproximado
                const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
                if (m) {
                    const r = parseInt(m[1], 10), g = parseInt(m[2], 10), b = parseInt(m[3], 10);
                    return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('').toUpperCase();
                }
            }
            if (c.startsWith('#') && c.length === 4) {
                // #RGB -> #RRGGBB
                c = '#' + c[1]+c[1] + c[2]+c[2] + c[3]+c[3];
            }
            if (!c.startsWith('#')) return c.toUpperCase();
            return c.toUpperCase();
        }

        function hexToRgb(hex) {
            const c = normalizeHex(hex);
            if (!c || !c.startsWith('#') || (c.length !== 7)) return null;
            return {
                r: parseInt(c.slice(1,3),16),
                g: parseInt(c.slice(3,5),16),
                b: parseInt(c.slice(5,7),16)
            };
        }

        function getLuminance(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return 0.5;
            const srgb = [rgb.r/255, rgb.g/255, rgb.b/255].map(v => {
                return v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4);
            });
            return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
        }

        function getContrastColor(hex) {
            const c = normalizeHex(hex);
            const lum = getLuminance(c);
            return lum > 0.5 ? '#000000' : '#FFFFFF';
        }

        function getContrastColorInline(hex) {
            // Helper para CSS inline cuando hay gradientes/badges
            try { return getContrastColor(hex); } catch(e) { return '#FFFFFF'; }
        }

        function colorsEqual(a,b) {
            return normalizeHex(a) === normalizeHex(b);
        }

        function resolveNoteColor(userColor, shifts) {
            // Si el color de la nota (usuario) coincide con alguno de los colores de turno del día,
            // usar un color con alto contraste para que se lea.
            const uc = normalizeHex(userColor);
            const shiftColors = (shifts||[]).map(s => {
                const t = shiftTemplates.find(t => t.name === s.text || t.abbreviation === s.text);
                return normalizeHex(t ? (t.backgroundColor || t.colorHex || t.color) : (s.userColor || getUserColor(s.userId)));
            }).filter(Boolean);
            const conflict = shiftColors.some(c => c === uc);
            if (conflict) {
                // Elegir blanco o negro según luminancia de ese color
                return getContrastColor(uc);
            }
            return userColor;
        }

        // Cambiar mes
        function changeMonth(delta) {
            currentDate.setMonth(currentDate.getMonth() + delta);
            renderCalendar(true); // Forzar render inmediato para cambio de mes
        }

        // Estado de año para vista anual
        let yearViewYear = null;
        function changeYear(delta) {
            if (yearViewYear == null) yearViewYear = currentDate.getFullYear();
            yearViewYear += delta;
            updateYearNav();
            renderYear();
            // Actualiza el texto del botón de pestaña del año si coincide con formato YYYY
            const yearTabBtn = Array.from(document.querySelectorAll('.tab-btn')).find(b => b.textContent.trim().match(/^\d{4}$/));
            if (yearTabBtn) yearTabBtn.textContent = String(yearViewYear);
        }

        function updateYearNav() {
            const title = document.getElementById('yearTitle');
            const yr = yearViewYear ?? currentUserYear();
            if (title) title.textContent = String(yr);
        }

        function currentUserYear() { return currentDate.getFullYear(); }

        // Renderizar vista anual rápida usando caché/localStorage
        async function renderYear() {
            const grid = document.getElementById('yearGrid');
            if (!grid) return;
            grid.innerHTML = '';

            const baseYear = yearViewYear ?? currentDate.getFullYear();
            for (let m = 0; m < 12; m++) {
                const monthBox = document.createElement('div');
                monthBox.className = 'year-month';
                monthBox.dataset.month = String(m);
                monthBox.dataset.year = String(baseYear);

                const header = document.createElement('div');
                header.className = 'year-month-header';
                header.textContent = monthNames[m].toUpperCase();
                monthBox.appendChild(header);

                const monthGrid = document.createElement('div');
                monthGrid.className = 'year-month-grid';

                // Encabezados de semana
                ['L','M','X','J','V','S','D'].forEach(w => {
                    const wEl = document.createElement('div');
                    wEl.className = 'year-weekday';
                    wEl.textContent = w;
                    monthGrid.appendChild(wEl);
                });

                const firstDay = new Date(baseYear, m, 1);
                const lastDay = new Date(baseYear, m + 1, 0);
                const daysInMonth = lastDay.getDate();
                const startDayOfWeek = firstDay.getDay();
                const adjustedStart = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Relleno inicial
                for (let i = 0; i < adjustedStart; i++) {
                    const dEl = document.createElement('div');
                    dEl.className = 'year-day other-month';
                    monthGrid.appendChild(dEl);
                }

                for (let d = 1; d <= daysInMonth; d++) {
                    const date = new Date(baseYear, m, d);
                    const dayEl = document.createElement('div');
                    dayEl.className = 'year-day';

                    const num = document.createElement('div');
                    num.className = 'year-day-number';
                    num.textContent = d;
                    dayEl.appendChild(num);

                    // Garantía de datos: usa caché si existe; si no, consulta inmediata
                    let events = getEventsForDateCached(date);
                    if (!events || events.length === 0) {
                        events = await getEventsForDate(date);
                    }
                    const shifts = events.filter(e => e.type !== 'note');
                    if (shifts.length > 0) {
                        if (shifts.length === 1) {
                            const ev = shifts[0];
                            const template = shiftTemplates.find(t => t.name === ev.text || t.abbreviation === ev.text);
                            const color = template ? (template.backgroundColor || template.colorHex || template.color) : (ev.userColor || getUserColor(ev.userId));
                            dayEl.style.background = color;
                            num.style.color = getContrastColor(color);
                            num.style.textShadow = '0 1px 2px rgba(0,0,0,0.35)';
                        } else if (shifts.length === 2) {
                            const s1 = shifts[0], s2 = shifts[1];
                            const t1 = shiftTemplates.find(t => t.name === s1.text || t.abbreviation === s1.text);
                            const t2 = shiftTemplates.find(t => t.name === s2.text || t.abbreviation === s2.text);
                            const c1 = t1 ? (t1.backgroundColor || t1.colorHex || t1.color) : (s1.userColor || getUserColor(s1.userId));
                            const c2 = t2 ? (t2.backgroundColor || t2.colorHex || t2.color) : (s2.userColor || getUserColor(s2.userId));
                            dayEl.style.background = `linear-gradient(to bottom, ${c1} 50%, ${c2} 50%)`;
                            num.style.color = '#FFFFFF';
                            num.style.textShadow = '0 1px 3px rgba(0,0,0,0.6)';
                        } else {
                            const s1 = shifts[0], s2 = shifts[1], s3 = shifts[2];
                            const t1 = shiftTemplates.find(t => t.name === s1.text || t.abbreviation === s1.text);
                            const t2 = shiftTemplates.find(t => t.name === s2.text || t.abbreviation === s2.text);
                            const t3 = shiftTemplates.find(t => t.name === s3.text || t.abbreviation === s3.text);
                            const c1 = t1 ? (t1.backgroundColor || t1.colorHex || t1.color) : (s1.userColor || getUserColor(s1.userId));
                            const c2 = t2 ? (t2.backgroundColor || t2.colorHex || t2.color) : (s2.userColor || getUserColor(s2.userId));
                            const c3 = t3 ? (t3.backgroundColor || t3.colorHex || t3.color) : (s3.userColor || getUserColor(s3.userId));
                            dayEl.style.background = `linear-gradient(to bottom, ${c1} 33.34%, ${c2} 33.34%, ${c2} 66.66%, ${c3} 66.66%)`;
                            num.style.color = '#FFFFFF';
                            num.style.textShadow = '0 1px 3px rgba(0,0,0,0.6)';
                        }
                    }

                    const today = new Date();
                    if (date.toDateString() === today.toDateString()) {
                        num.style.backgroundColor = '#FF1744';
                        num.style.color = '#fff';
                        num.style.borderRadius = '50%';
                        num.style.padding = '1px 4px';
                        num.style.textShadow = 'none';
                    }

                    monthGrid.appendChild(dayEl);
                }

                // Completar el final hasta múltiplo de 7
                const used = adjustedStart + daysInMonth;
                const rest = (7 - (used % 7)) % 7;
                for (let i = 0; i < rest; i++) {
                    const dEl = document.createElement('div');
                    dEl.className = 'year-day other-month';
                    monthGrid.appendChild(dEl);
                }

                monthBox.appendChild(monthGrid);
                // Evitar duplicados: reemplazar si ya existe un mes con mismo índice
                const existing = grid.querySelector(`.year-month[data-year="${baseYear}"][data-month="${m}"]`);
                if (existing) {
                    grid.replaceChild(monthBox, existing);
                } else {
                    grid.appendChild(monthBox);
                }
            }
        }

        

        // Abrir modal de día
        async function openDayModal(date) {
            selectedDate = date;
            
            // Actualizar fecha en formato D/M/YY
            const day = date.getDate();
            const month = date.getMonth() + 1;
            const year = date.getFullYear().toString().slice(-2);
            document.getElementById('modalDate').textContent = `${day}/${month}/${year}`;
            
            // Cargar notas existentes del día
            await loadDayNotes(date);
            
            // Cargar y mostrar turnos del día
            await loadDayShifts(date);
            
            // Cargar alarmas y actualizar contador
            await loadAlarms();
            
            document.getElementById('dayModal').classList.add('show');
        }

        // Cargar notas del día desde Firebase
        async function loadDayNotes(date) {
            try {
                // Obtener eventos del día
                const events = await getEventsForDate(date);
                
                // Buscar la nota del día (debería haber solo una)
                const note = events.find(event => event.type === 'note');
                
                if (note) {
                    // Mostrar la nota en el textarea
                    document.getElementById('mainTextarea').value = note.text;
                    
                    // Cargar categorías si existen
                    if (note.categories && note.categories.length > 0) {
                        loadCategories(note.categories);
                    } else {
                        resetCategories();
                    }
                    
                    console.log('✅ Nota cargada para el día:', note.text);
                } else {
                    // Limpiar textarea si no hay nota
                    document.getElementById('mainTextarea').value = '';
                    resetCategories();
                    console.log('ℹ️ No hay nota para este día');
                }
                
            } catch (error) {
                console.error('❌ Error cargando notas del día:', error);
                document.getElementById('mainTextarea').value = '';
                resetCategories();
            }
        }

        // Cargar categorías en los dropdowns
        function loadCategories(categories) {
            for (let i = 0; i < 3; i++) {
                if (i < categories.length) {
                    const category = categories[i];
                    const dropdown = document.getElementById(`dropdown-${i}`);
                    if (dropdown) {
                        const iconElement = dropdown.querySelector('.no-icon');
                        const textElement = dropdown.querySelector('.dropdown-text');
                        if (iconElement && textElement) {
                            iconElement.textContent = category.icon;
                            textElement.textContent = category.text;
                        }
                    }
                } else {
                    resetCategory(i);
                }
            }
        }

        // Resetear categorías
        function resetCategories() {
            for (let i = 0; i < 3; i++) {
                resetCategory(i);
            }
        }

        // Resetear una categoría específica
        function resetCategory(index) {
            const dropdown = document.getElementById(`dropdown-${index}`);
            if (dropdown) {
                const iconElement = dropdown.querySelector('.no-icon');
                const textElement = dropdown.querySelector('.dropdown-text');
                if (iconElement && textElement) {
                    iconElement.textContent = '🚫';
                    textElement.textContent = 'Ninguno';
                }
            }
        }

        // Cargar turnos del día desde Firebase
        async function loadDayShifts(date) {
            const shiftsContent = document.getElementById('shiftsContent');
            
            try {
                // Obtener eventos del día
                const events = await getEventsForDate(date);
                
                // Filtrar solo turnos (excluir notas con type='note')
                const shifts = events.filter(event => event.type !== 'note');
                
                if (shifts.length === 0) {
                    shiftsContent.innerHTML = `
                        <div class="clock-icon">🕐</div>
                        <div class="no-shifts-text">No hay turnos asignados</div>
                    `;
                    return;
                }
                
                // Limpiar contenido
                shiftsContent.innerHTML = '';
                
                // Mostrar cada turno
                shifts.forEach(shift => {
                    const shiftItem = document.createElement('div');
                    shiftItem.className = 'shift-item';
                    
                    // Buscar el shift template correspondiente
                    const template = shiftTemplates.find(t => t.name === shift.text || t.abbreviation === shift.text);
                    
                    if (template) {
                        shiftItem.innerHTML = `
                            <div class="shift-circle" style="background-color: ${template.colorHex}"></div>
                            <div class="shift-name">${template.name}</div>
                        `;
                    } else {
                        // Fallback si no se encuentra template
                        shiftItem.innerHTML = `
                            <div class="shift-circle"></div>
                            <div class="shift-name">${shift.text}</div>
                        `;
                    }
                    
                    shiftsContent.appendChild(shiftItem);
                });
                
                console.log('✅ Turnos cargados para el día:', shifts.length);
                
            } catch (error) {
                console.error('❌ Error cargando turnos del día:', error);
                shiftsContent.innerHTML = `
                    <div class="clock-icon">🕐</div>
                    <div class="no-shifts-text">Error cargando turnos</div>
                `;
            }
        }

        // Cerrar modal
        function closeModal() {
            document.getElementById('dayModal').classList.remove('show');
        }

        // Variables para el modal de notas
        let originalNoteText = '';
        let originalNoteTextSize = 11; // Tamaño por defecto
        let currentFormatState = {
            bold: false,
            italic: false,
            underline: false
        };

        // Abrir modal de notas
        async function openNotesPopup() {
            const textarea = document.getElementById('mainTextarea');
            originalNoteText = textarea.value || '';
            
            // Cargar el texto actual en el modal de notas
            const notesTextarea = document.getElementById('notesTextarea');
            // Si es contentEditable, usar innerHTML/textContent
            if (notesTextarea.contentEditable === 'true') {
                notesTextarea.innerHTML = originalNoteText.replace(/\n/g, '<br>');
                if (notesTextarea.innerHTML === '') {
                    notesTextarea.textContent = '';
                }
            } else {
                notesTextarea.value = originalNoteText;
            }
            
            // Cargar el tamaño de texto guardado si existe
            if (selectedDate) {
                try {
                    const events = await getEventsForDate(selectedDate);
                    const note = events.find(event => event.type === 'note');
                    if (note && note.textSize) {
                        originalNoteTextSize = parseInt(note.textSize) || 11;
                    } else {
                        originalNoteTextSize = 11; // Por defecto
                    }
                } catch (error) {
                    console.error('Error cargando tamaño de texto:', error);
                    originalNoteTextSize = 11;
                }
            } else {
                originalNoteTextSize = 11;
            }
            
            // Actualizar el slider y el valor mostrado
            const slider = document.getElementById('notesTextSizeSlider');
            const valueDisplay = document.getElementById('notesTextSizeValue');
            if (slider && valueDisplay) {
                slider.value = originalNoteTextSize;
                valueDisplay.textContent = originalNoteTextSize;
                console.log('📏 Tamaño de texto cargado:', originalNoteTextSize);
            }
            
            // Resetear formato
            resetFormatButtons();
            
            // Mostrar el modal
            document.getElementById('notesModal').classList.add('show');
            
            // Agregar event listeners para actualizar botones de formato
            notesTextarea.addEventListener('mouseup', updateFormatButtons);
            notesTextarea.addEventListener('keyup', updateFormatButtons);
            notesTextarea.addEventListener('selectionchange', updateFormatButtons);
            
            // Enfocar el campo de texto
            setTimeout(() => {
                notesTextarea.focus();
            }, 100);
        }
        
        // Actualizar el tamaño de texto mostrado
        function updateNotesTextSize(value) {
            document.getElementById('notesTextSizeValue').textContent = value;
        }

        // Cerrar modal de notas sin guardar
        function cancelNotesPopup() {
            // Cerrar el modal sin guardar cambios
            document.getElementById('notesModal').classList.remove('show');
        }

        // Aceptar cambios del modal de notas
        async function acceptNotesPopup() {
            const notesTextarea = document.getElementById('notesTextarea');
            let newText = '';
            
            // Obtener el texto según el tipo de elemento
            if (notesTextarea.contentEditable === 'true') {
                // Para contentEditable, obtener texto sin HTML pero preservar saltos de línea
                newText = notesTextarea.innerText || notesTextarea.textContent || '';
            } else {
                newText = notesTextarea.value || '';
            }
            
            // Obtener el tamaño de texto seleccionado
            const slider = document.getElementById('notesTextSizeSlider');
            const textSize = slider ? parseInt(slider.value) || 11 : 11;
            
            console.log('📏 Tamaño de texto seleccionado:', textSize);
            
            // Actualizar el textarea principal del modal de día
            document.getElementById('mainTextarea').value = newText.trim();
            
            // Guardar inmediatamente en Firebase si hay fecha seleccionada
            if (selectedDate) {
                try {
                    const existingEvents = await getEventsForDate(selectedDate);
                    const existingNoteIndex = existingEvents.findIndex(event => event.type === 'note');
                    
                    console.log('📝 Nota existente encontrada:', existingNoteIndex !== -1);
                    if (existingNoteIndex !== -1) {
                        console.log('📝 Nota existente antes de actualizar:', JSON.stringify(existingEvents[existingNoteIndex]));
                    }
                    
                    if (newText.trim() === '') {
                        // Si no hay texto, eliminar la nota existente
                        if (existingNoteIndex !== -1) {
                            existingEvents.splice(existingNoteIndex, 1);
                        }
                    } else {
                        const noteEvent = {
                            text: newText.trim(),
                            textSize: textSize, // Guardar el tamaño del texto
                            userId: currentUserId,
                            userColor: getUserColor(currentUserId),
                            createdAt: existingNoteIndex !== -1 ? existingEvents[existingNoteIndex].createdAt : new Date().toISOString(),
                            updatedAt: new Date().toISOString(),
                            categories: existingNoteIndex !== -1 && existingEvents[existingNoteIndex].categories ? existingEvents[existingNoteIndex].categories : [],
                            type: 'note'
                        };
                        
                        console.log('💾 Nota a guardar:', JSON.stringify(noteEvent));
                        
                        if (existingNoteIndex !== -1) {
                            existingEvents[existingNoteIndex] = noteEvent;
                            console.log('✏️ Nota actualizada en índice:', existingNoteIndex);
                        } else {
                            existingEvents.push(noteEvent);
                            console.log('📝 Nueva nota agregada');
                        }
                    }
                    
                    await saveEvents(selectedDate, existingEvents);
                    console.log('✅ Nota guardada en Firebase con textSize:', textSize);
                    
                    // Verificar que se guardó correctamente
                    const verifyEvents = await getEventsForDate(selectedDate);
                    const verifyNote = verifyEvents.find(event => event.type === 'note');
                    if (verifyNote) {
                        console.log('✅ Verificación: Nota guardada con textSize:', verifyNote.textSize);
                    } else {
                        console.warn('⚠️ Verificación: No se encontró la nota después de guardar');
                    }
                    
                    // Refrescar el calendario para mostrar el nuevo tamaño
                    scheduleRenderCalendar();
                } catch (error) {
                    console.error('❌ Error guardando nota:', error);
                }
            }
            
            // Cerrar el modal
            document.getElementById('notesModal').classList.remove('show');
        }

        // Borrar nota (sin cerrar el pop-up)
        function deleteNote() {
            const notesTextarea = document.getElementById('notesTextarea');
            
            // Limpiar el contenido editable
            if (notesTextarea.contentEditable === 'true') {
                notesTextarea.innerHTML = '';
                notesTextarea.textContent = '';
            } else {
                notesTextarea.value = '';
            }
            
            // También actualizar el textarea principal (pero no cerrar el modal)
            document.getElementById('mainTextarea').value = '';
            
            // Resetear formato
            resetFormatButtons();
            
            // Enfocar el campo de texto
            notesTextarea.focus();
        }

        // Aplicar formato de texto (bold, italic, underline)
        function toggleFormat(format) {
            const notesTextarea = document.getElementById('notesTextarea');
            
            // Verificar que sea contentEditable
            if (notesTextarea.contentEditable !== 'true') {
                return;
            }
            
            // Asegurar que el elemento tenga foco
            notesTextarea.focus();
            
            // Usar document.execCommand para aplicar formato
            let command = '';
            switch(format) {
                case 'bold':
                    command = 'bold';
                    break;
                case 'italic':
                    command = 'italic';
                    break;
                case 'underline':
                    command = 'underline';
                    break;
            }
            
            if (command) {
                try {
                    document.execCommand(command, false, null);
                    
                    // Actualizar el estado visual del botón
                    const btn = document.getElementById('format' + format.charAt(0).toUpperCase() + format.slice(1));
                    const isActive = document.queryCommandState(command);
                    
                    btn.classList.toggle('active', isActive);
                    currentFormatState[format] = isActive;
                } catch (e) {
                    console.error('Error aplicando formato:', e);
                }
            }
            
            // Volver a enfocar el campo de texto
            notesTextarea.focus();
        }
        
        // Actualizar el estado de los botones de formato según la selección
        function updateFormatButtons() {
            const notesTextarea = document.getElementById('notesTextarea');
            if (notesTextarea.contentEditable !== 'true') return;
            
            // Verificar el estado de cada formato
            const boldActive = document.queryCommandState('bold');
            const italicActive = document.queryCommandState('italic');
            const underlineActive = document.queryCommandState('underline');
            
            // Actualizar los botones
            document.getElementById('formatBold').classList.toggle('active', boldActive);
            document.getElementById('formatItalic').classList.toggle('active', italicActive);
            document.getElementById('formatUnderline').classList.toggle('active', underlineActive);
            
            // Actualizar el estado
            currentFormatState.bold = boldActive;
            currentFormatState.italic = italicActive;
            currentFormatState.underline = underlineActive;
        }

        // Resetear botones de formato
        function resetFormatButtons() {
            document.getElementById('formatBold').classList.remove('active');
            document.getElementById('formatItalic').classList.remove('active');
            document.getElementById('formatUnderline').classList.remove('active');
            currentFormatState = {
                bold: false,
                italic: false,
                underline: false
            };
        }

        // Manejar clic fuera del modal para cerrarlo
        function handleNotesModalClick(event) {
            if (event.target.id === 'notesModal') {
                cancelNotesPopup();
            }
        }
        
        // Agregar listener para cambios de selección (para actualizar botones de formato)
        document.addEventListener('selectionchange', function() {
            const modal = document.getElementById('notesModal');
            if (modal && modal.classList.contains('show')) {
                updateFormatButtons();
            }
        });

        // Variables para alarmas
        let alarms = [];
        
        // Detectar dispositivo móvil
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isAndroid = /Android/i.test(navigator.userAgent);

        // Cargar alarmas desde Firebase
        async function loadAlarms() {
            if (!selectedDate) {
                console.log('⚠️ loadAlarms: No hay fecha seleccionada');
                return [];
            }
            
            try {
                const events = await getEventsForDate(selectedDate);
                const note = events.find(event => event.type === 'note');
                
                if (note && note.alarms && Array.isArray(note.alarms)) {
                    alarms = note.alarms;
                    console.log(`✅ Alarmas cargadas: ${alarms.length} alarmas para ${formatDateKey(selectedDate)}`);
                    console.log('📋 Contenido de alarmas cargadas:', JSON.stringify(alarms));
                } else {
                    alarms = [];
                    if (note) {
                        console.log(`ℹ️ Nota encontrada pero sin alarmas para ${formatDateKey(selectedDate)}`);
                    } else {
                        console.log(`ℹ️ No se encontró nota para ${formatDateKey(selectedDate)}`);
                    }
                }
                updateAlarmCount();
                return alarms;
            } catch (error) {
                console.error('❌ Error cargando alarmas:', error);
                alarms = [];
                return alarms;
            }
        }

        // Actualizar el contador de alarmas
        function updateAlarmCount() {
            const alarmNumber = document.getElementById('alarmNumber');
            if (alarmNumber) {
                alarmNumber.textContent = alarms.length;
            }
        }

        // Abrir modal de alarma
        async function openAlarmModal() {
            // Cargar alarmas existentes
            await loadAlarms();
            
            // Establecer fecha por defecto al día seleccionado
            if (selectedDate) {
                const dateStr = selectedDate.toISOString().split('T')[0];
                document.getElementById('alarmDateInput').value = dateStr;
            }
            
            // Limpiar hora
            document.getElementById('alarmTimeInput').value = '';
            
            // Mostrar alarmas existentes
            renderAlarmsList();
            
            // Mostrar el modal
            document.getElementById('alarmModal').classList.add('show');
        }

        // Cerrar modal de alarma
        function closeAlarmModal() {
            document.getElementById('alarmModal').classList.remove('show');
        }

        // Manejar clic fuera del modal
        function handleAlarmModalClick(event) {
            if (event.target.id === 'alarmModal') {
                closeAlarmModal();
            }
        }

        // Renderizar lista de alarmas
        function renderAlarmsList() {
            const alarmList = document.getElementById('alarmList');
            alarmList.innerHTML = '';
            
            if (alarms.length === 0) {
                alarmList.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">No hay alarmas configuradas</div>';
                return;
            }
            
            alarms.forEach((alarm, index) => {
                const item = document.createElement('div');
                item.className = 'alarm-item';
                
                const date = new Date(alarm.dateTime);
                const dateStr = date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: '2-digit' });
                const timeStr = date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
                
                item.innerHTML = `
                    <div class="alarm-item-info">
                        <div class="alarm-item-date">${dateStr}</div>
                        <div class="alarm-item-time">${timeStr}</div>
                    </div>
                    <button class="alarm-item-delete" onclick="deleteAlarm(${index})">×</button>
                `;
                
                alarmList.appendChild(item);
            });
        }

        // Agregar alarma
        async function addAlarm() {
            const dateInput = document.getElementById('alarmDateInput').value;
            const timeInput = document.getElementById('alarmTimeInput').value;
            
            if (!dateInput || !timeInput) {
                console.warn('⚠️ Por favor completa fecha y hora');
                return;
            }
            
            // Crear objeto de fecha y hora
            const dateTime = new Date(`${dateInput}T${timeInput}`);
            
            // Verificar que la fecha no sea en el pasado
            if (dateTime < new Date()) {
                console.warn('⚠️ No se puede configurar una alarma en el pasado');
                return;
            }
            
            // Agregar alarma a la lista
            const alarm = {
                dateTime: dateTime.toISOString(), // Guardar como string ISO para Firebase
                id: Date.now().toString() // ID único para la alarma (como string)
            };
            
            alarms.push(alarm);
            console.log('➕ Alarma agregada:', JSON.stringify(alarm));
            
            // Guardar alarmas en Firebase
            await saveAlarms();
            
            // Limpiar inputs
            document.getElementById('alarmTimeInput').value = '';
            
            // Actualizar lista
            renderAlarmsList();
            updateAlarmCount();
        }

        // Eliminar alarma
        async function deleteAlarm(index) {
            if (index >= 0 && index < alarms.length) {
                alarms.splice(index, 1);
                await saveAlarms();
                renderAlarmsList();
                updateAlarmCount();
            }
        }

        // Guardar alarmas en Firebase
        async function saveAlarms() {
            if (!selectedDate) return;
            
            try {
                const existingEvents = await getEventsForDate(selectedDate);
                const existingNoteIndex = existingEvents.findIndex(event => event.type === 'note');
                
                if (existingNoteIndex !== -1) {
                    // Actualizar nota existente con alarmas, preservando todos los demás campos
                    const existingNote = existingEvents[existingNoteIndex];
                    existingEvents[existingNoteIndex] = {
                        ...existingNote, // Preservar todos los campos existentes
                        alarms: alarms,
                        updatedAt: new Date().toISOString()
                    };
                    console.log('✅ Nota actualizada con alarmas:', alarms.length, 'alarmas');
                    console.log('📋 Contenido de alarmas:', JSON.stringify(alarms));
                } else {
                    // Crear nota con alarmas
                    const noteEvent = {
                        text: '',
                        userId: currentUserId,
                        userColor: getUserColor(currentUserId),
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        categories: [],
                        alarms: alarms,
                        type: 'note',
                        textSize: 11 // Tamaño por defecto
                    };
                    existingEvents.push(noteEvent);
                    console.log('✅ Nueva nota creada con alarmas:', alarms.length, 'alarmas');
                }
                
                await saveEvents(selectedDate, existingEvents);
                console.log('✅ Alarmas guardadas en Firebase:', alarms.length);
                
                // Verificar que se guardaron correctamente
                const verifyEvents = await getEventsForDate(selectedDate);
                const verifyNote = verifyEvents.find(event => event.type === 'note');
                if (verifyNote && verifyNote.alarms) {
                    console.log('✅ Verificación: Alarmas guardadas correctamente:', verifyNote.alarms.length);
                    console.log('📋 Alarmas verificadas:', JSON.stringify(verifyNote.alarms));
                } else {
                    console.warn('⚠️ Advertencia: No se encontraron alarmas después de guardar');
                }
                
                // Guardar también en localStorage para verificación local (especialmente iOS)
                saveAlarmsToLocalStorage();
                
                // Configurar notificaciones y programar en Service Worker
                setupAlarmNotifications();
                if (!isIOS) {
                    scheduleAllAlarms();
                } else {
                    // En iOS, programar en localStorage para verificación cuando la app se abre
                    scheduleAlarmsForIOS();
                    console.log('ℹ️ iOS: Alarmas programadas para verificación cuando la app se abra');
                }
            } catch (error) {
                console.error('❌ Error guardando alarmas:', error);
            }
        }

        // Programar todas las alarmas en el Service Worker
        async function scheduleAllAlarms() {
            if (!('serviceWorker' in navigator)) return;
            
            try {
                const registration = await navigator.serviceWorker.ready;
                const now = new Date();
                
                // Obtener todas las alarmas de los próximos 30 días
                for (let i = 0; i < 30; i++) {
                    const checkDate = new Date(now);
                    checkDate.setDate(checkDate.getDate() + i);
                    
                    try {
                        const events = await getEventsForDate(checkDate);
                        const note = events.find(event => event.type === 'note');
                        
                        if (note && note.alarms && Array.isArray(note.alarms)) {
                            note.alarms.forEach(alarm => {
                                const alarmDate = new Date(alarm.dateTime);
                                const timeUntilAlarm = alarmDate.getTime() - now.getTime();
                                
                                // Solo programar alarmas futuras (próximas 30 días)
                                if (timeUntilAlarm > 0 && timeUntilAlarm <= 30 * 24 * 60 * 60 * 1000) {
                                    const alarmDateStr = alarmDate.toISOString().split('T')[0];
                                    const alarmTimeStr = alarmDate.toTimeString().split(' ')[0].slice(0, 5);
                                    const noteText = note.text || '';
                                    const currentUser = users.find(u => u.id === currentUserId);
                                    const userName = currentUser ? currentUser.name : 'Usuario';
                                    
                                    // Enviar mensaje al Service Worker para programar la alarma
                                    const message = {
                                        type: 'SCHEDULE_ALARM',
                                        alarmDate: alarmDateStr,
                                        alarmTime: alarmTimeStr,
                                        noteText: noteText,
                                        userName: userName,
                                        alarmId: alarm.id
                                    };
                                    
                                    if (registration.active) {
                                        registration.active.postMessage(message);
                                    } else if (registration.waiting) {
                                        registration.waiting.postMessage(message);
                                        // Activar el SW waiting si es posible
                                        registration.waiting.addEventListener('statechange', function() {
                                            if (registration.waiting.state === 'activated') {
                                                registration.waiting.postMessage(message);
                                            }
                                        });
                                    } else {
                                        // Si no hay SW activo, guardar el mensaje para cuando esté listo
                                        registration.addEventListener('updatefound', () => {
                                            const newWorker = registration.installing;
                                            if (newWorker) {
                                                newWorker.addEventListener('statechange', () => {
                                                    if (newWorker.state === 'activated' && navigator.serviceWorker.controller) {
                                                        navigator.serviceWorker.controller.postMessage(message);
                                                    }
                                                });
                                            }
                                        });
                                    }
                                }
                            });
                        }
                    } catch (error) {
                        // Continuar con el siguiente día si hay error
                        continue;
                    }
                }
                
                console.log('✅ Alarmas programadas en Service Worker');
            } catch (error) {
                console.error('❌ Error programando alarmas en SW:', error);
            }
        }

        // Guardar alarmas en localStorage para verificación cuando la app se abre
        function saveAlarmsToLocalStorage() {
            try {
                // Obtener todas las alarmas de los próximos 30 días
                const allAlarms = [];
                const now = new Date();
                
                // Guardar timestamp de última verificación
                localStorage.setItem('last_alarm_check', now.toISOString());
                
                const alarmsData = {
                    lastSaved: now.toISOString(),
                    alarms: alarms, // Alarmas del día actual
                    version: '2.0'
                };
                localStorage.setItem('pending_alarms', JSON.stringify(alarmsData));
                console.log('💾 Alarmas guardadas en localStorage para verificación local');
            } catch (error) {
                console.error('Error guardando alarmas en localStorage:', error);
            }
        }
        
        // Detectar cuando la app vuelve al primer plano (iOS)
        function setupVisibilityChangeListener() {
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    // La app volvió al primer plano
                    console.log('📱 App vuelta al primer plano - verificando alarmas pendientes');
                    
                    // Verificar inmediatamente alarmas que pudieron haberse perdido
                    setTimeout(() => {
                        checkPendingAlarmsOnStart();
                        checkAlarms();
                    }, 500);
                } else {
                    // La app se fue a segundo plano - guardar estado
                    console.log('📱 App en segundo plano - guardando estado');
                    saveAlarmsToLocalStorage();
                }
            });
            
            // También detectar cuando la ventana recibe foco
            window.addEventListener('focus', () => {
                console.log('📱 Ventana recibió foco - verificando alarmas');
                setTimeout(() => {
                    checkPendingAlarmsOnStart();
                    checkAlarms();
                }, 500);
            });
        }
        
        // Verificar si la app está instalada como PWA
        function checkPWAInstallation() {
            // Verificar si se está ejecutando en modo standalone (PWA instalada)
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches ||
                                window.navigator.standalone ||
                                document.referrer.includes('android-app://');
            
            if (isStandalone) {
                console.log('✅ PWA instalada detectada - mejores capacidades disponibles');
                // Cuando está instalada como PWA, puede tener más permisos
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission();
                }
            } else if (isIOS) {
                console.log('ℹ️ Para mejor funcionalidad en iPhone, instala la app:');
                console.log('   1. Toca el botón Compartir (cuadrado con flecha)');
                console.log('   2. Selecciona "Añadir a pantalla de inicio"');
                console.log('   3. Abre la app desde el icono en la pantalla de inicio');
                
                // Mostrar un mensaje visual la primera vez
                const hasSeenPWAMessage = localStorage.getItem('pwa_install_message_seen');
                if (!hasSeenPWAMessage && isIOS) {
                    setTimeout(() => {
                        const pwaHint = document.createElement('div');
                        pwaHint.style.cssText = `
                            position: fixed;
                            bottom: 20px;
                            left: 10px;
                            right: 10px;
                            background: #FF9800;
                            color: white;
                            padding: 15px;
                            border-radius: 10px;
                            z-index: 10000;
                            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                            font-size: 14px;
                            line-height: 1.5;
                        `;
                        pwaHint.innerHTML = `
                            <strong>💡 Mejora las alarmas en iPhone:</strong><br>
                            Instala esta app tocando <strong>Compartir</strong> → <strong>"Añadir a pantalla de inicio"</strong>
                            <button onclick="this.parentElement.remove(); localStorage.setItem('pwa_install_message_seen', 'true');" 
                                    style="float: right; margin-top: 5px; background: white; color: #FF9800; border: none; padding: 5px 10px; border-radius: 5px; font-weight: bold; cursor: pointer;">
                                ✕
                            </button>
                        `;
                        document.body.appendChild(pwaHint);
                    }, 3000);
                }
            }
            
            return isStandalone;
        }
        
        // Programar alarmas para iOS usando localStorage (para verificación cuando la app se abre)
        async function scheduleAlarmsForIOS() {
            try {
                const now = new Date();
                const scheduledAlarms = [];
                
                // Obtener todas las alarmas de los próximos 7 días
                for (let i = 0; i < 7; i++) {
                    const checkDate = new Date(now);
                    checkDate.setDate(checkDate.getDate() + i);
                    
                    try {
                        const events = await getEventsForDate(checkDate);
                        const note = events.find(event => event.type === 'note');
                        
                        if (note && note.alarms && Array.isArray(note.alarms)) {
                            note.alarms.forEach(alarm => {
                                const alarmDate = new Date(alarm.dateTime);
                                const timeUntilAlarm = alarmDate.getTime() - now.getTime();
                                
                                // Solo programar alarmas futuras
                                if (timeUntilAlarm > 0) {
                                    scheduledAlarms.push({
                                        id: alarm.id,
                                        dateTime: alarm.dateTime,
                                        date: alarmDate.toISOString().split('T')[0],
                                        time: alarmDate.toTimeString().split(' ')[0].slice(0, 5),
                                        noteText: note.text || ''
                                    });
                                }
                            });
                        }
                    } catch (error) {
                        continue;
                    }
                }
                
                // Guardar en localStorage para verificación cuando la app se abre
                localStorage.setItem('ios_scheduled_alarms', JSON.stringify({
                    alarms: scheduledAlarms,
                    lastUpdated: now.toISOString()
                }));
                
                console.log(`✅ ${scheduledAlarms.length} alarmas programadas para verificación en iOS`);
            } catch (error) {
                console.error('Error programando alarmas para iOS:', error);
            }
        }
        
        // Verificar alarmas pendientes al abrir la app (especialmente importante para iOS)
        async function checkPendingAlarmsOnStart() {
            try {
                const now = new Date();
                const checkedAlarmIds = new Set();
                let foundAlarms = false;
                
                // Obtener última verificación
                const lastCheck = localStorage.getItem('last_alarm_check');
                const lastCheckTime = lastCheck ? new Date(lastCheck) : null;
                
                // Si no hay última verificación, buscar en las últimas 24 horas
                const checkRange = lastCheckTime ? 
                    Math.max(1, Math.ceil((now - lastCheckTime) / (1000 * 60 * 60))) : 24; // Horas
                
                console.log(`🔍 Verificando alarmas perdidas (últimos ${checkRange} horas o 7 días)`);
                
                // Verificar alarmas de los últimos 7 días (o desde última verificación)
                const daysToCheck = Math.min(7, Math.ceil(checkRange / 24) + 1);
                
                for (let i = 0; i < daysToCheck; i++) {
                    const checkDate = new Date(now);
                    checkDate.setDate(checkDate.getDate() - i); // Verificar días pasados también
                    
                    try {
                        const events = await getEventsForDate(checkDate);
                        const note = events.find(event => event.type === 'note');
                        
                        if (note && note.alarms && Array.isArray(note.alarms)) {
                            note.alarms.forEach(alarm => {
                                if (checkedAlarmIds.has(alarm.id)) return;
                                checkedAlarmIds.add(alarm.id);
                                
                                const alarmDate = new Date(alarm.dateTime);
                                const diff = alarmDate.getTime() - now.getTime();
                                
                                // Si la alarma era en el pasado (se perdió mientras la app estaba cerrada)
                                // Verificar desde la última verificación o máximo 30 minutos atrás
                                const maxTimeBack = lastCheckTime ? 
                                    (now - lastCheckTime) : (30 * 60 * 1000); // 30 minutos por defecto
                                
                                if (diff < 0 && diff > -maxTimeBack) {
                                    console.log(`🔔 Alarma perdida detectada: ${alarm.id} (hace ${Math.round(-diff/1000)}s)`);
                                    foundAlarms = true;
                                    const noteText = note.text || '';
                                    
                                    // Mostrar notificación inmediatamente
                                    setTimeout(() => {
                                        showAlarmNotification(alarm, noteText);
                                    }, 100);
                                }
                            });
                        }
                    } catch (error) {
                        continue;
                    }
                }
                
                // Verificar también alarmas programadas en localStorage (iOS)
                if (isIOS) {
                    const iosAlarms = localStorage.getItem('ios_scheduled_alarms');
                    if (iosAlarms) {
                        try {
                            const data = JSON.parse(iosAlarms);
                            data.alarms.forEach(alarm => {
                                if (checkedAlarmIds.has(alarm.id)) return;
                                checkedAlarmIds.add(alarm.id);
                                
                                const alarmDate = new Date(alarm.dateTime);
                                const diff = alarmDate.getTime() - now.getTime();
                                
                                const maxTimeBack = lastCheckTime ? 
                                    (now - lastCheckTime) : (30 * 60 * 1000);
                                
                                if (diff < 0 && diff > -maxTimeBack) {
                                    console.log(`🔔 Alarma iOS perdida detectada: ${alarm.id}`);
                                    foundAlarms = true;
                                    
                                    setTimeout(() => {
                                        showAlarmNotification({id: alarm.id, dateTime: alarm.dateTime}, alarm.noteText);
                                    }, 100);
                                }
                            });
                        } catch (e) {
                            console.error('Error verificando alarmas iOS:', e);
                        }
                    }
                }
                
                // Actualizar timestamp de última verificación
                localStorage.setItem('last_alarm_check', now.toISOString());
                
                if (!foundAlarms) {
                    console.log('✅ No se encontraron alarmas perdidas');
                } else {
                    console.log('⚠️ Alarmas perdidas encontradas y mostradas');
                }
            } catch (error) {
                console.error('Error verificando alarmas pendientes:', error);
            }
        }
        
        // Configurar notificaciones de alarmas
        function setupAlarmNotifications() {
            // Limpiar notificaciones anteriores
            clearInterval(window.alarmCheckInterval);
            
            // Verificar alarmas cada minuto (o cada 30 segundos en móviles para mejor respuesta)
            const checkInterval = isMobile ? 30000 : 60000;
            
            window.alarmCheckInterval = setInterval(() => {
                checkAlarms();
            }, checkInterval);
            
            console.log(`⏰ Verificación de alarmas cada ${checkInterval/1000} segundos (${isMobile ? 'móvil' : 'escritorio'})`);
            
            // Verificar inmediatamente
            checkAlarms();
        }

        // Verificar si alguna alarma debe activarse
        async function checkAlarms() {
            const now = new Date();
            const checkedAlarmIds = new Set(); // Para evitar duplicados
            let totalAlarmsChecked = 0;
            
            try {
                // Verificar alarmas del día actual y los próximos 7 días
                for (let i = 0; i < 7; i++) {
                    const checkDate = new Date(now);
                    checkDate.setDate(checkDate.getDate() + i);
                    const dateKey = formatDateKey(checkDate);
                    
                    try {
                        const events = await getEventsForDate(checkDate);
                        const note = events.find(event => event.type === 'note');
                        
                        if (note && note.alarms && Array.isArray(note.alarms)) {
                            console.log(`🔍 Verificando ${note.alarms.length} alarmas para ${dateKey}`);
                            
                            note.alarms.forEach(alarm => {
                                // Evitar verificar la misma alarma dos veces
                                if (checkedAlarmIds.has(alarm.id)) return;
                                checkedAlarmIds.add(alarm.id);
                                totalAlarmsChecked++;
                                
                                const alarmDate = new Date(alarm.dateTime);
                                const diff = alarmDate.getTime() - now.getTime();
                                
                                console.log(`⏰ Alarma ${alarm.id}: fecha=${alarmDate.toISOString()}, diff=${Math.round(diff/1000)}s`);
                                
                                // Si la alarma es ahora o en los próximos 60 segundos
                                if (diff >= 0 && diff <= 60000) {
                                    console.log(`🔔 ¡ALARMA ACTIVADA! ${alarm.id} - Diferencia: ${Math.round(diff/1000)}s`);
                                    const noteText = note.text || '';
                                    showAlarmNotification(alarm, noteText);
                                }
                            });
                        }
                    } catch (error) {
                        console.error(`Error verificando alarmas para ${dateKey}:`, error);
                        // Continuar con el siguiente día si hay error
                        continue;
                    }
                }
                
                if (totalAlarmsChecked > 0) {
                    console.log(`✅ Verificación completada: ${totalAlarmsChecked} alarmas verificadas`);
                }
            } catch (error) {
                console.error('❌ Error verificando alarmas:', error);
            }
        }

        // Mostrar notificación de alarma
        async function showAlarmNotification(alarm, alarmNoteText = '') {
            const alarmDate = new Date(alarm.dateTime);
            const dateStr = alarmDate.toISOString().split('T')[0];
            const timeStr = alarmDate.toTimeString().split(' ')[0].slice(0, 5);
            
            // Obtener texto de la nota si no se proporcionó
            let noteText = alarmNoteText;
            if (!noteText) {
                try {
                    const events = await getEventsForDate(new Date(alarm.dateTime));
                    const note = events.find(event => event.type === 'note');
                    if (note && note.text) {
                        noteText = note.text;
                    }
                } catch (error) {
                    console.error('Error obteniendo nota para alarma:', error);
                }
            }
            
            // Abrir página de notificación
            openAlarmNotificationPage(dateStr, timeStr, noteText);
            
            // También mostrar notificación del navegador si está permitido
            if ('Notification' in window) {
                if (Notification.permission === 'granted') {
                    try {
                        const notification = new Notification('🔔 Recordatorio', {
                            body: `Tienes una alarma configurada para ${alarmDate.toLocaleString('es-ES')}`,
                            icon: 'icons/Icon-192.png',
                            tag: `alarm-${alarm.id}`,
                            requireInteraction: true,
                            data: {
                                url: `alarm-notification.html?date=${dateStr}&time=${timeStr}&note=${encodeURIComponent(noteText)}&user=${encodeURIComponent(users.find(u => u.id === currentUserId)?.name || 'Usuario')}`
                            }
                        });
                        
                        notification.onclick = function() {
                            openAlarmNotificationPage(dateStr, timeStr, noteText);
                            window.focus();
                            notification.close();
                        };
                    } catch (error) {
                        console.log('Error mostrando notificación (permiso puede haber sido revocado):', error);
                        // Continuar - la página de alarma ya se abrió
                    }
                } else if (Notification.permission === 'default') {
                    // Solicitar permiso solo si es la primera vez
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            // Si ahora se otorgó el permiso, mostrar notificación
                            try {
                                const notification = new Notification('🔔 Recordatorio', {
                                    body: `Tienes una alarma configurada para ${alarmDate.toLocaleString('es-ES')}`,
                                    icon: 'icons/Icon-192.png',
                                    tag: `alarm-${alarm.id}`,
                                    requireInteraction: true
                                });
                                
                                notification.onclick = function() {
                                    openAlarmNotificationPage(dateStr, timeStr, noteText);
                                    window.focus();
                                    notification.close();
                                };
                            } catch (error) {
                                console.log('Error mostrando notificación después de otorgar permiso:', error);
                            }
                        }
                    });
                }
                // Si el permiso es 'denied', simplemente no mostramos notificación pero sí la página
            }
        }

        // Abrir página de notificación de alarma
        function openAlarmNotificationPage(dateStr, timeStr, noteText) {
            // Obtener nombre del usuario actual
            const currentUser = users.find(u => u.id === currentUserId);
            const userName = currentUser ? currentUser.name : 'Usuario';
            
            // Construir URL con parámetros
            const params = new URLSearchParams({
                date: dateStr,
                time: timeStr,
                note: encodeURIComponent(noteText || ''),
                user: encodeURIComponent(userName)
            });
            
            // Abrir en nueva ventana/pestaña o redirigir
            const alarmUrl = `alarm-notification.html?${params.toString()}`;
            
            console.log('🔔 Abriendo página de alarma:', alarmUrl);
            
            // En móviles, mejor redirigir directamente en la misma ventana
            if (isMobile) {
                console.log('📱 Dispositivo móvil detectado: redirigiendo a pantalla de alarma');
                window.location.href = alarmUrl;
                return;
            }
            
            // En escritorio, intentar abrir en nueva ventana
            try {
                // Usar window.open con características específicas para pantalla completa
                const alarmWindow = window.open(
                    alarmUrl, 
                    'alarmWindow',
                    'width=' + screen.width + ',height=' + screen.height + ',left=0,top=0,fullscreen=yes'
                );
                
                if (alarmWindow) {
                    alarmWindow.focus();
                    console.log('✅ Ventana de alarma abierta');
                } else {
                    // Si falla por bloqueo del navegador, redirigir en la misma ventana
                    console.log('⚠️ No se pudo abrir nueva ventana, redirigiendo en la misma ventana');
                    window.location.href = alarmUrl;
                }
            } catch (error) {
                console.error('Error abriendo ventana de alarma:', error);
                // Fallback: redirigir en la misma ventana
                window.location.href = alarmUrl;
            }
        }

        // Obtener categorías seleccionadas
        function getSelectedCategories() {
            const categories = [];
            for (let i = 0; i < 3; i++) {
                // Buscar el dropdown por su ID
                const dropdown = document.getElementById(`dropdown-${i}`);
                if (dropdown) {
                    // Los elementos están en el parentElement del dropdown
                    const dropdownContainer = dropdown.parentElement;
                    const textElement = dropdownContainer.querySelector('.dropdown-text');
                    const iconElement = dropdownContainer.querySelector('.no-icon');
                    
                    console.log(`🔍 Dropdown ${i}:`, {
                        dropdown: dropdown,
                        dropdownContainer: dropdownContainer,
                        textElement: textElement?.textContent,
                        iconElement: iconElement?.textContent
                    });
                    
                    if (textElement && iconElement) {
                        const selectedText = textElement.textContent;
                        const selectedIcon = iconElement.textContent;
                        
                        console.log(`📝 Categoría ${i}: "${selectedText}" con icono "${selectedIcon}"`);
                        
                        if (selectedText !== 'Ninguno' && selectedText.trim() !== '') {
                            categories.push({
                                text: selectedText,
                                icon: selectedIcon
                            });
                            console.log(`✅ Categoría ${i} agregada:`, {text: selectedText, icon: selectedIcon});
                        } else {
                            console.log(`⏭️ Categoría ${i} omitida (Ninguno o vacía)`);
                        }
                    } else {
                        console.log(`❌ No se encontraron elementos para dropdown ${i}`);
                        // Intentar con selectores alternativos
                        const altTextElement = dropdownContainer.querySelector('span.dropdown-text');
                        const altIconElement = dropdownContainer.querySelector('div.no-icon');
                        console.log(`🔄 Selectores alternativos:`, {
                            altTextElement: altTextElement?.textContent,
                            altIconElement: altIconElement?.textContent
                        });
                    }
                } else {
                    console.log(`❌ No se encontró dropdown ${i}`);
                }
            }
            console.log('📋 Categorías finales:', categories);
            return categories;
        }

        // Aceptar cambios del día
        async function acceptDayChanges() {
            const mainText = document.getElementById('mainTextarea').value;
            const selectedCategories = getSelectedCategories();
            
            console.log('✅ Cambios aceptados para el día:', selectedDate);
            console.log('📝 Nota principal:', mainText);
            console.log('🏷️ Categorías seleccionadas:', selectedCategories);
            
            try {
                // Obtener eventos existentes del día
                const existingEvents = await getEventsForDate(selectedDate);
                
                // Buscar si ya existe una nota para este día
                const existingNoteIndex = existingEvents.findIndex(event => event.type === 'note');
                
                if (mainText.trim() === '') {
                    // Si no hay texto, eliminar la nota existente
                    if (existingNoteIndex !== -1) {
                        existingEvents.splice(existingNoteIndex, 1);
                        console.log('🗑️ Nota eliminada');
                    }
                } else {
                    // Crear o actualizar la nota
                    // Preservar textSize y alarmas existentes si existen
                    const existingNote = existingNoteIndex !== -1 ? existingEvents[existingNoteIndex] : null;
                    const noteEvent = {
                        text: mainText.trim(),
                        userId: currentUserId,
                        userColor: getUserColor(currentUserId),
                        createdAt: existingNoteIndex !== -1 ? existingEvents[existingNoteIndex].createdAt : new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        categories: selectedCategories,
                        type: 'note',
                        // Preservar textSize si existe, si no usar el por defecto
                        textSize: existingNote && existingNote.textSize ? existingNote.textSize : 11,
                        // Preservar alarmas si existen
                        alarms: existingNote && existingNote.alarms && Array.isArray(existingNote.alarms) ? existingNote.alarms : []
                    };
                    
                    if (existingNoteIndex !== -1) {
                        // Actualizar nota existente
                        existingEvents[existingNoteIndex] = noteEvent;
                        console.log('✏️ Nota actualizada con textSize:', noteEvent.textSize, 'y alarmas:', noteEvent.alarms.length);
                    } else {
                        // Crear nueva nota
                        existingEvents.push(noteEvent);
                        console.log('📝 Nueva nota creada con textSize:', noteEvent.textSize);
                    }
                }
                
                // Guardar en Firebase
                await saveEvents(selectedDate, existingEvents);
                
                console.log('✅ Cambios guardados en Firebase');
                
            } catch (error) {
                console.error('❌ Error guardando cambios:', error);
            }
            
            closeModal();
        }

        // Toggle dropdown
        function toggleDropdown(index) {
            // Cerrar todos los otros dropdowns
            for (let i = 0; i < 3; i++) {
                if (i !== index) {
                    const dropdown = document.getElementById(`dropdown-${i}`);
                    dropdown.classList.remove('show');
                }
            }
            
            // Toggle el dropdown actual
            const dropdown = document.getElementById(`dropdown-${index}`);
            dropdown.classList.toggle('show');
        }

        // Seleccionar categoría
        async function selectCategory(index, text, icon) {
            const dropdown = document.querySelector(`#dropdown-${index}`);
            const dropdownText = dropdown.parentElement.querySelector('.dropdown-text');
            const dropdownIcon = dropdown.parentElement.querySelector('.no-icon');
            
            // Actualizar texto e icono
            dropdownText.textContent = text;
            dropdownIcon.textContent = icon || '🚫';
            
            // Cerrar dropdown
            dropdown.classList.remove('show');
            
            console.log(`✅ Categoría ${index + 1} seleccionada:`, text);
            
            // Guardar categorías inmediatamente en Firebase
            await saveCategoriesToFirebase();
        }

        // Guardar categorías en Firebase inmediatamente
        async function saveCategoriesToFirebase() {
            if (!selectedDate || !isFirebaseConnected) {
                console.log('⚠️ No se puede guardar categorías - selectedDate:', selectedDate, 'isFirebaseConnected:', isFirebaseConnected);
                return;
            }

            try {
                const selectedCategories = getSelectedCategories();
                console.log('📝 Categorías seleccionadas:', selectedCategories);
                
                // Obtener eventos existentes del día
                const existingEvents = await getEventsForDate(selectedDate);
                console.log('📅 Eventos existentes:', existingEvents);
                
                // Buscar si ya existe una nota para este día
                const existingNoteIndex = existingEvents.findIndex(event => event.type === 'note');
                console.log('🔍 Índice de nota existente:', existingNoteIndex);
                
                if (existingNoteIndex !== -1) {
                    // Actualizar categorías de la nota existente
                    existingEvents[existingNoteIndex].categories = selectedCategories;
                    existingEvents[existingNoteIndex].updatedAt = new Date().toISOString();
                    
                    console.log('✏️ Actualizando nota existente con categorías:', existingEvents[existingNoteIndex]);
                    
                    // Guardar en Firebase
                    await saveEvents(selectedDate, existingEvents);
                    console.log('✅ Categorías guardadas en Firebase inmediatamente');
                } else {
                    // Si no hay nota, crear una temporal solo con categorías
                    const noteEvent = {
                        text: '', // Nota vacía
                        userId: currentUserId,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        categories: selectedCategories,
                        type: 'note'
                    };
                    
                    console.log('📝 Creando nueva nota con categorías:', noteEvent);
                    
                    existingEvents.push(noteEvent);
                    await saveEvents(selectedDate, existingEvents);
                    console.log('✅ Categorías guardadas en Firebase (nota temporal creada)');
                }
                
            } catch (error) {
                console.error('❌ Error guardando categorías:', error);
            }
        }

        // Cerrar dropdowns al hacer clic fuera
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.category-dropdown')) {
                for (let i = 0; i < 3; i++) {
                    const dropdown = document.getElementById(`dropdown-${i}`);
                    dropdown.classList.remove('show');
                }
            }
        });

        // Agregar evento
        async function addEvent() {
            const select = document.getElementById('shiftSelect');
            const text = select.value.trim();

            if (!text) {
                console.warn('⚠️ Por favor selecciona un turno');
                return;
            }

            const events = await getEventsForDate(selectedDate);
            events.push({
                text: text,
                userId: currentUserId,
                createdAt: new Date().toISOString()
            });

            await saveEvents(selectedDate, events);
            await openDayModal(selectedDate); // Refrescar modal
            select.value = '';
        }

        // Eliminar evento
        async function deleteEvent(index) {
            const events = await getEventsForDate(selectedDate);
            events.splice(index, 1);
            await saveEvents(selectedDate, events);
            await openDayModal(selectedDate); // Refrescar modal
        }

        // Volver a selector de usuarios
        function goBack() {
            window.location.href = 'iphone.html';
        }

        // Cerrar modal al hacer clic fuera
        document.getElementById('dayModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        // Función para agregar eventos de prueba (deshabilitada)
        async function addTestEvents() {
            // Datos de prueba deshabilitados - usar Firebase
            console.log('ℹ️ Datos de prueba deshabilitados - usando Firebase');
        }

        // Mostrar turnos
        function showShifts() {
            window.location.href = 'shifts.html';
        }

        // Inicializar cuando cargue la página
        window.addEventListener('load', init);

        // Asegurar que los botones de acción sean visibles
        window.addEventListener('DOMContentLoaded', () => {
            const bottomActions = document.querySelector('.bottom-actions');
            if (bottomActions) {
                bottomActions.style.display = 'flex';
                bottomActions.style.visibility = 'visible';
                bottomActions.style.opacity = '1';
                console.log('✅ Botones de acción asegurados como visibles');
            } else {
                console.error('❌ No se encontró la barra de botones');
            }
        });

        // Script de depuración para verificar botones
        setTimeout(() => {
            const bottomActions = document.querySelector('.bottom-actions');
            console.log('🔍 Estado de los botones:', {
                elemento: bottomActions,
                display: bottomActions ? getComputedStyle(bottomActions).display : 'N/A',
                visibility: bottomActions ? getComputedStyle(bottomActions).visibility : 'N/A',
                opacity: bottomActions ? getComputedStyle(bottomActions).opacity : 'N/A',
                height: bottomActions ? getComputedStyle(bottomActions).height : 'N/A',
                zIndex: bottomActions ? getComputedStyle(bottomActions).zIndex : 'N/A',
            });
        }, 1000);
    </script>
</body>
</html>

